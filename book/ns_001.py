# Глава 8. (стр 436) Подробнее о строковых данных

# Доступ к отдельным символам и строковым значениям  возможен при применении цикла for и индексации:

# Один из самых простых способов получить доступ к отдельным символам в строковом зна­чении состоит в применении цикла for.

# for переменная in строковое_значение:
#   инструкция
#   инструкция

#  Во время каждой ите­рации цикла переменная будет ссылаться на копию символа в строковом значении, начиная с первого символа. Мы говорим, что цикл выполняет последовательный перебор символов в строковом значении.
'''
name = 'Джулия'
for ch in name:
    print (ch)
# Д
# ж
# y
# л
# и
# я
'''
# В программе 8.1 приведен еще один пример. Эта программа просит пользователя ввести строковое значение. Затем она применяет цикл for для обхода строкового значения, подсчи­тывая количество появлений буквы Т (в верхнем или нижнем регистре). Предположим будет введено предложение: " Кто не ходит, тот и не падает."
'''
def main():
    # Для подсчёта кол-ва букв создадим переменную:
    count = 0
    my_string = input('Enter offer: ')
    for ch in my_string.lower():
        if ch == 'т':
            count += 1
    print(count)
if __name__ == '__main__':
    main()
# 5
'''
# Индексация

# Еще один способ получить доступ к отдельным символам в строковом значении реализуется при помощи индекса. Каждый символ в строковом значении имеет индекс, который задает его позицию. Индексация начинается с О, поэтому индекс первого символа равняется О, ин­декс второго символа равняется 1 и т. д. Индекс последнего символа в строковом значении равняется количеству символов в строковом значении минус 1.
'''
my_string = 'Ромашки белые'
ch = my_string[6]
print(ch)
# и
print(my_string[-1], my_string[-2], my_string[-13])
# e ы P
print(my_string[-14])
# IndexError
'''
# Функция len

# В главе 7 вы познакомились с функцией len, которая возвращает длину последовательности. Функция len также используется для получения длины строкового значения.
'''
city = 'Бостон'
size = len (city)
print(size)
# 6
'''
# Функция len в особенности полезна для предотвращения ситуаций, когда циклы заходят запределы конца строкового значения с получением IndexError:
'''
city = 'Бостон'
index = 0
while index < len(city):
    index += 1
print(index)
# 6
'''
# Конкатенация строковых данных

# конка­тенация, или присоединение одного строкового значения в конец другого.

# Оператор + порождает строковое значение, которое является объединением двух других строковых значений, используемых в качестве его операндов.
'''
first_name = 'Emily'
last_name = 'Egger'
full_name = first_name + ' ' + last_name
print(full_name)
# Emily Egger
'''
# Для выполнения конкатенации можно также использовать оператор +=.
'''
letters = 'asdf'
letters += '1234'
print(letters)
# asdf1234
'''
# Следует иметь в виду, что операнд с левой стороны от оператора+= должен быть существующей переменной. Если указать несуществующую переменную, то будет вызвано исклю­чение.

# Строковые данные как немутируемые последовательности

# В Python данные строкового типа являются немутируемыми последовательностями, т. е. по­сле создания их нельзя изменить. Некоторые операции, такие как конкатенация, производят впечатление, что они видоизменяют строковые данные, но в действительности этого не про­исходит. Значения литералов как были так и остались в неприкосновенности. Произошло лишь соединение литералов и переприсваивание переменной нового значения.


# МЕТОДЫ ПРОВЕРКИ СТРОКОВЫХ ЗНАЧЕНИЙ

# БУЛЕВЫЕ: (начинются на is)

#  метод isdigit() возвращает True, если строковое зна­чение содержит только цифры. В противном случае он возвращает False.

# isalpha() Возвращает True, если строковое значение содержит только буквы алфавита и имеет по крайней мере один символ. В противном случае возвращает False

# isalnum() Возвращает True, если строковое значение содержит только буквы алфавита или цифры и имеет по крайней мере один символ. В противном случае возвращает False

# islower () Возвращает True, если все буквы алфавита в строковом значении находятся в нижнем регистре, и строковая последовательность содержит по крайней мере одну букву алфавита.В противном случае возвращает False

# isspace() Возвращает True, если строковое значение содержит только пробельные символы и имеет по крайней мере один символ. В противном случае возвращает False. (Пробельными символами являются пробелы, символы новой строки (\n) и символы табуляции (\t).)

# isupper() Возвращает True, если все буквы алфавита в строковом значении находятся в верхнем регистре, и строковая последовательность содержит по крайней мере одну букву алфавита. В противном случае возвращает False


# МЕТОДЫ МОДИФИКАЦИИ СТРОКОВЫХ ЗНАЧЕНИЙ:

# Несмотря на то что строковые данные являются немутируемыми последовательностями, т. е. их нельзя изменить, они имеют много методов, которые возвращают их видоизмененные версии:

# lower() Возвращает копmо строкового значения, в котором все буквы преобразованы в нижний регистр . Любой символ, который уже находится в нижнем регистре или не является буквой алфавита, остается без изменения.

# lstrip() Возвращает копmо строкового значения, в котором все ведущие пробельные символы удалены. Ведущими пробельными символами являются пробелы, символы новой строки (\n) и символы табуляции (\t), которые появляются в начале строкового значения

# lstrip(символ) Аргументом <символ> является строковое значение, содержащее символ. Возвращает копию строкового значения, в котором удалены все экземпляры символа, появляющиеся в начале(left слева) строкового значения.

# rstrip() Возвращает копию строкового значения, в котором все замыкающие пробельные символы удалены. Замыкающими пробельными символами являются пробелы, символы новой строки (\n) и символы табуляции(\t), которые появляются в конце строкового значения.

# rstrip(символ) Аргументом <символ> является строковое значение, содержащее символ. Возвращает копию строковой последовательности, в которой удалены все экземпляры символа, появляющиеся в конце строкового значения.

# strip() Возвращает копию строкового значения, в котором удалены все ведущие и замыкающие пробельные символы.

# strip(символ) Возвращает копmо строкового значения, в котором удалены все экземпляры символа, появляющиеся в начале и конце строкового значения.

# upper() Возвращает копmо строкового значения, в котором все буквы преобразованы в верхний регистр . Любой символ, который уже находится в верхнем регистре или не является буквой алфавита, остается без изменения.


# МЕТОДЫ ПОИСКА И ЗАМЕНЫ:

# выполняют поиск подстрок, а также метод, который заменяет найденные подстроки другой подстрокой.

# andswith(подстрока) Аргумент <подстрока> это строковое значение. Метод возвращает истину, если строковое значение заканчивается подстрокой.

# find(подстрока) Аргумент <подстрока> это строковое значение. Метод возвращает наименьший индекс в строковом значении, где найдена подстрока. Если подстрока не найдена, метод возвращает -1.

# replace(старое, новое) Аргументы <старое и новое> - это строковые значения. Метод возвращает копию строкового значения, в котором все экземпляры старых подстрок заменены новыми подстроками.

# startswith(подстрока) Аргумент подстрока - это строковое значение. Метод возвращает истину, если строковое значение начинается с подстроки.


# ОПЕРАТОР ПОВТОРЕНИЯ:

# копируемое_ с троковое_ значение * n

# Например:
'''
my_string = 'w' * 5
print(my_string)
# wwwww
'''
# Программа 8.8 демонстрирует оператор повторения:
'''
def main():
    for count in range(1, 4):
        print('z' * count)
    for count in range(4, 0, -1):
        print('z' * count)
if __name__ == '__main__':
    main()
# z
# zz
# zzz
# zzzz
# zzz
# zz
# z
'''


# РАЗБИЕНИЕ СТРОКОВОГО ЗНАЧЕНИЯ: методом:

# split() метод возвращает список, стоковых значений.

# В программе 8.9 приведен пример:
'''
def main():
    my_string = 'One Two Three Four'
    word_list = my_string.split()
    print(word_list)
if __name__ == '__main__':
    main()
# ['One', 'Two', 'Three', 'Four']
'''
'''
date_string = '26/11/2020'
date_list = date_string.split('/')
'''
# print(date_list)
# ['26', '11', '2020']
'''
print(f'Day: {date_list[0]}')
print(f'month: {date_list[1]}')
print(f'Year: {date_list[2]}')
'''
# Day: 26
# month: 11
# Year: 2020


# СТРОКОВЫЕ ЛЕКСЕМЫ:

# В Python для лексемизации строк используется метод split(). Програм­ма 8.11 демонстрирует его работу:
'''
def main():
    str1 = 'One Two Three Four'
    str2 = '10:20:30:40'
    str3 = 'a/b/c/d'
    
    display_tokens(str1, ' ')
    print()
    display_tokens(str2, ':')
    print()
    display_tokens(str3, '/')
    print()    

def display_tokens(data, delimiter):
    tokens = data.split(delimiter)
    for i in tokens:
        print(f'Leksem: {i}')
if __name__ == '__main__':
    main()
'''

# Глава 8. УПРАЖНЕНИЯ ПО ПРОГРАММИРОВАНИЮ:
