# Уроки Python с нуля / #17 – Основы ООП. Создание класса и объекта (Школа itProger)

# https://www.youtube.com/watch?v=gFRa6qVN980&list=PLDyJYA6aTY1lPWXBPk0gw6gR8fEtPDGKa&index=18


# В уроке рассматриваются основы объектно-ориентированного программирования на Python. Объясняются классы и объекты, наследование, полиморфизм и инкапсуляция. Приводятся примеры с роботами и котами, демонстрируется создание классов и объектов, а также методы для работы с ними, что упрощает структуру кода и повышает его читаемость.


# Основные моменты:
# 00:05 Объектно-ориентированное программирование (ООП) позволяет структурировать код, создавая классы и объекты. Это упрощает разработку и поддержание сложных программных систем.
#   -Классы служат чертежами для объектов, описывая их характеристики и функционал. Объекты создаются на основе этих классов и обладают своими уникальными свойствами.
#   -Наследование позволяет расширять функционал классов, добавляя новые возможности. Это помогает создавать более сложные и специализированные объекты на основе базовых.
#   -Инкапсуляция защищает данные объектов, ограничивая доступ к их внутренним элементам. Это обеспечивает безопасность и целостность данных в программе.

# 02:19 Классы и объекты в программировании позволяют организовать код более эффективно, объединяя методы и переменные. Это упрощает создание объектов с уникальными характеристиками, основанными на общем классе.
#   -Создание класса включает использование ключевого слова 'класс' и указание его названия, что позволяет структурировать код. Это помогает избежать загромождения кода множеством переменных.
#   -Внутри класса можно определить поля, которые будут хранить информацию о каждом объекте. Например, это могут быть имя, возраст и состояние счастья кота.
#   -Классы позволяют использовать различные типы данных, такие как списки и словари, для хранения информации. Это делает код более гибким и расширяемым для будущих нужд.

# 04:37 В данном уроке мы создаем объекты на основе класса, демонстрируя, как можно задавать различные характеристики для каждого объекта. Это позволяет эффективно управлять данными и их свойствами.
#   -Первый объект создается с именем и возрастом, что позволяет наглядно увидеть, как данные связаны с конкретным экземпляром класса. Это важный шаг в объектно-ориентированном программировании.
#   -Второй объект создается с другими значениями, показывая, что объекты могут иметь уникальные характеристики, даже если они основаны на одном классе. Это иллюстрирует принцип наследования.
#   -Хранение всех характеристик объектов в одном месте облегчает управление данными и добавление нового функционала, что делает код более организованным и гибким. Это ключевой принцип ООП.

# 06:54 Классы и объекты позволяют организовать код, описывая общие характеристики в одном месте. Это упрощает создание различных объектов с уникальными значениями и функционалом.
#   -Создание объектов на основе одного класса позволяет организовать код и избежать дублирования. Каждый объект может иметь уникальные значения при общем функционале.
#   -Общие характеристики классов упрощают управление данными. Это позволяет легко изменять или добавлять функции, доступные для всех объектов данного класса.
#   -Функции, определенные в классе, автоматически доступны для всех его объектов. Это облегчает использование и повторное использование кода в программировании.

# 09:13 Классы в программировании позволяют организовать данные и методы для работы с ними. Они обеспечивают структурированное взаимодействие с полями и параметрами объектов.
#   -Первый параметр в классе является обязательным для обращения к полям. Он помогает интерпретатору понять, к какому значению нужно обратиться внутри класса.
#   -Практика именования параметров в классе обычно совпадает с названиями полей. Это облегчает понимание и уменьшает вероятность ошибок при установке значений.
#   -Использование ключевого слова 'self' позволяет четко указывать, к какому полю класса мы обращаемся. Это необходимо для передачи значений в соответствующие поля.

# 11:32 Методы и функции в программировании это одно и то же, хотя методы используются внутри классов, а функции вне их. Они выполняют одинаковые задачи, но имеют разные контексты применения.
#   -Метод сет дата устанавливает значения для объекта, принимая три параметра. Это позволяет сократить код и сделать его более читаемым.
#   -Метод дед дата возвращает полную характеристику объекта, не принимая параметров. Он позволяет получить информацию о свойствах объекта в удобном формате.
#   -Объекты могут вызывать методы для получения информации, что упрощает работу с данными. Это дает возможность выводить разные свойства объектов одним вызовом.

# 13:50 Классы в программировании позволяют создавать множество объектов с общими функциями и характеристиками, при этом значения могут различаться. Это значительно упрощает код и увеличивает его читабельность.
#   -Классы дают возможность создавать до 200 объектов, каждый из которых имеет доступ к одним и тем же функциям. Это обеспечивает гибкость и повторное использование кода.
#   -Каждый объект может иметь уникальные значения для своих характеристик, что делает их независимыми и позволяет использовать классы в различных сценариях. Это повышает универсальность кода.
#   -Использование классов значительно сокращает количество строк кода и улучшает его структуру. Это позволяет разработчикам легче понимать и поддерживать проект.

# class Cat:
#     name = None
#     age = None
#     isHappy = None


# # создадим два объекта с разными характеристиками, принадлежащие одноме классу Cat:
# cat1 = Cat()
# cat1.name = 'Barsic'
# cat1.age = 3
# cat1.isHappy = True

# cat2 = Cat()
# cat2.name = 'Gopen'
# cat2.age = 2
# cat2.isHappy = False

# print(cat1.name)     # Barsic
# print(cat2.name)     # Gopen

# Мы можем к классу добавить дополнительные ф-ии (методы) например set_data() которая будет принимать некоторые параметры (извне) и устанавливать их в поля(переменные) класса Cat. Параметр self см. описание выше.

# class Cat:
#     name = None
#     age = None
#     isHappy = None

#     def set_data(self, name, age, isHappy):
#         self.name = name
#         self.age = age
#         self.isHappy = isHappy

# # Добавим еще метод который ничего не принимает, но будет возвращать характеристики к.л. объекта:
#     def get_data(self):
#         print(self.name, 'age:', self.age, 'Happy:', self.isHappy)

# cat1 = Cat()
# cat1.set_data('Barsic', 3, True)

# cat2 = Cat()
# cat2.set_data('Gopen', 2, False)
# # теперь эти принты не нужны - закоментируем их:
# # print(cat1.name)     # Barsic
# # print(cat2.name)     # Gopen

# # но запишем обращение к get_data для вывода инфы о котах:
# cat1.get_data()     # Barsic age: 3 Happy: True
# cat2.get_data()     # Gopen age: 2 Happy: False


# Уроки Python с нуля / #18 – Конструкторы, переопределение методов

# https://www.youtube.com/watch?v=Y6N-na2WOx8&list=PLDyJYA6aTY1lPWXBPk0gw6gR8fEtPDGKa&index=18


# class Cat:
#     # добавим конструктор:
#     # Инициализация атрибутов класса
#     def __init__(self, name, age, isHappy):
#         self.set_data(name, age, isHappy)
#         self.get_data()

#     # Метод для установки данных
#     def set_data(self, name, age, isHappy):
#         self.name = name    # правильно инициализируем атрибут
#         self.age = age      # правильно инициализируем атрибут
#         self.isHappy = isHappy  # правильно инициализируем атрибут

#     # Метод для получения данных
#     def get_data(self):
#         print(self.name, 'age:', self.age, 'Happy:', self.isHappy)

# # Создаем экземпляры (объекты) класса Cat
# cat1 = Cat('Barsic', 3, True)
# cat2 = Cat('Gopen', 2, False)

# # Barsic age: 3 Happy: True
# # Gopen age: 2 Happy: False


# Для успешного переопределения методов нам необходимо в конструкторе - задать параметры атрибутов по умолчанию (наример None либо задать какие-то конкретные данные (это могут быть любые типы данных(строки, числа, множества и тд))). Это может быть нужно для того, чтобы можно было передавать  ограниченный перечень атрибутов без ошибки.
# Например:

# class Cat:
#     # добавим конструктор:
#     # Инициализация атрибутов класса
#     def __init__(self, name = None, age = None, isHappy = None):
#         self.set_data(name, age, isHappy)
#         self.get_data()

#     # Метод для установки данных
#     def set_data(self, name, age, isHappy):
#         self.name = name    # правильно инициализируем атрибут
#         self.age = age      # правильно инициализируем атрибут
#         self.isHappy = isHappy  # правильно инициализируем атрибут

#     # Метод для получения данных
#     def get_data(self):
#         print(self.name, 'age:', self.age, 'Happy:', self.isHappy)

# # Создаем экземпляры (объекты) класса Cat
# cat1 = Cat('Barsic', 3)
# cat2 = Cat('Gopen',)
# # Barsic age: 3 Happy: None
# # Gopen age: None Happy: None


# Уроки Python с нуля / #19 – Наследование, инкапсуляция, полиморфизм

# https://www.youtube.com/watch?v=4N4GSzLF7JM&list=PLDyJYA6aTY1lPWXBPk0gw6gR8fEtPDGKa&index=19

# В уроке рассматриваются основные концепции программирования на Python: наследование, инкапсуляция и полиморфизм. Объясняется, как создавать классы и наследовать их свойства, а также как защищать данные и изменять методы в дочерних классах. Важность этих концепций подчеркивается через примеры с классами зданий.

# В уроке рассматриваются основные концепции программирования на Python: наследование, инкапсуляция и полиморфизм. Объясняется, как создавать классы и наследовать их свойства, а также как защищать данные и изменять методы в дочерних классах. Важность этих концепций подчеркивается через примеры с классами зданий.


# Основные моменты:

# 00:18 Наследование является одной из ключевых концепций в программировании. Оно позволяет создавать классы-наследники, которые унаследуют свойства и методы от родительского класса.
#   -Инкапсуляция подразумевает скрытие внутренней реализации класса от внешнего мира. Это помогает защитить данные и управлять доступом к ним.
#   -Полиморфизм позволяет использовать общий интерфейс для объектов разных классов. Это упрощает код и делает его более гибким и переиспользуемым.
#   -Создание дополнительных классов для специализированных объектов помогает избежать избыточности кода. Это делает его более понятным и облегчает дальнейшую поддержку.
# 04:03 Наследование классов в программировании позволяет создавать новые классы на основе существующих, сохраняя общие характеристики. Это упрощает код и делает его более организованным.
#   -Создание класса 'школа', который наследует все характеристики от класса 'building'. Это позволяет добавлять специфические функции для школы без изменения основного класса.
#   -Аналогичное наследование можно применять для других классов, таких как 'дом' и 'магазин', что позволяет создать специальные функции для каждого типа объекта.
#   -Дополнительные характеристики, такие как количество учеников, могут быть добавлены в класс 'школа', не затрагивая другие классы, что делает код более чистым.
# 10:00 Наследование в программировании позволяет создавать дочерние классы, которые используют свойства и методы родительского класса. Это упрощает код и делает его более структурированным.
#   -Передача данных в конструктор родительского класса осуществляется с помощью функции super, что помогает избежать дублирования кода. Это важно для поддержания чистоты и логики программы.
#   -Наследование позволяет дочерним классам получать все поля и методы родительского класса, что способствует повторному использованию кода. Это особенно полезно в больших проектах.
#   -В Python невозможно использовать множественное наследование, что предотвращает путаницу и ошибки, связанные с несколькими родительскими классами. Это отличает Python от других языков, таких как C++.
# 12:10 Классы могут наследоваться друг от друга, что позволяет создавать иерархии классов. Это дает возможность использовать свойства родительского класса в дочерних классах.
#   -Наследник может иметь свои собственные классы, что расширяет функционал. Это позволяет создавать более сложные структуры и использовать уже существующие методы.
#   -Полиморфизм позволяет переопределять методы родительского класса в дочерних классах. Это дает возможность адаптировать поведение методов в зависимости от класса.
#   -Методы, переопределенные в дочерних классах, могут содержать дополнительную функциональность. Это позволяет использовать их в зависимости от контекста вызова.
# 16:12 Инкапсуляция - это важная концепция, которая обеспечивает защиту данных в классах. В языке Python реализация инкапсуляции не так хорошо развита, как в других языках программирования.
#   -Концепция инкапсуляции подразумевает, что доступ к полям класса должен быть ограничен. Это обеспечивает безопасность и предотвращает случайное изменение данных.
#   -В Python инкапсуляция не является строгой. Программисты могут использовать нижние подчеркивания для обозначения защищенных полей, но доступ к ним все равно возможен.
#   -Ошибки при попытке доступа к защищенным полям могут возникать только при выводе их на экран. Это демонстрирует, что инкапсуляция в Python не является абсолютной.


# class Building:
#     year = None
#     city = None

#     def __init__(self, year, city):
#         self.year = year
#         self.city = city

#     def get_info(self):
#         print('Год постройки:', self.year, 'Город:', self.city)


# class School(Building):
#     pupils = 0

#     def __init__(self, pupils, year, city):
#         super(School, self).__init__(year, city)
#         self.pupils = pupils

#     def get_info(self):
#         super().get_info()
#         print('Pupils', self.pupils)


# class House(Building):
#     pass


# class Shop(Building):
#     pass


# school = School(100, 2001, 'Cheboksary')
# school.get_info()

# house = House(2002, 'Moscow')
# house.get_info()

# shop = Shop(2003, 'Kazan')
# shop.get_info()



# ДЕКОРАТОРЫ ФУНКЦИЙ (МЕТОДОВ)
