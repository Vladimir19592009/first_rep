# 35. Функции: первое знакомство, определение def и их вызов.
# (https://www.youtube.com/watch?v=NUrEyTW4JuU&list=PLA0M1Bcd0w8yWHh2V70bTtbVxJICrnJHd)

# В Python существует множество стандартных, встроенных функций, но на все случаи жизни их не придумаешь. Поэтому, программист может сам создавать свои собственные по мере необходимости. Для этого используется следующий синтаксис:

# def <имя функции>([список аргументов]):
#         оператор 1
#         оператор 2
#         …
#         оператор N

#  имя функции придумывается программистом подобно именам переменных и, так как функция – это определенное действие, то ее имя следует выбирать как глагол, например:

# go, show, get, set и т.п.

# Далее, идет набор операторов, которые образуют тело функции. Именно они начинают выполнятся при ее вызове.
# Давайте в качестве примера, зададим простую функцию, которая будет имитировать отправку письма:

# def send_mail():
#     text = "Уважаемый, Сергей Балакирев! Я так и не понял, что такое функция. Объясните лучше!"
#     print(text)


# send_mail()

# обратите внимание, мы можем вызывать функцию только после ее объявления. То есть, сначала сделать ее вызов, а потом объявить не получится, возникнет ошибка, что имя send_mail не определено. Нужно сначала объявлять функции и только потом их вызывать.
# Сейчас у нашей функции нет никаких параметров. Давайте добавим один с именем отправителя:

# def send_mail(from_name):
#     text = f"""Уважаемый, Сергей Балакирев!
# Я так и не понял, что такое функция.
# Объясните лучше!
# Ваш, навсегда {from_name}!"""
#     print(text)


# send_mail("Иван Иванович")

# Для этого в круглых скобках записываем параметр с именем from_name и, затем, в многострочной F-строке мы добавим это имя в конце сообщения.
# функции нужно передавать ровно столько аргументов, сколько параметров в ней определено. Давайте пропишем второй параметр – возраст отправителя:

# def send_mail(from_name, old):
#     text = f"""Уважаемый, Сергей Балакирев!
# Я так и не понял, что такое функция.
# Объясните лучше!
# Ваш, навсегда {from_name}! И не судите строго, мне всего {old} лет."""

#     print(text)


# send_mail("Иван Иванович", 7)


# 36. Оператор return в функциях. Функциональное программирование
# (https://www.youtube.com/watch?v=D2uB3vqMTzI&list=PLA0M1Bcd0w8yWHh2V70bTtbVxJICrnJHd)

# давайте объявим функцию, которая бы вычисляла квадратный корень из положительных чисел:

# def get_sqrt(x):
#     res = None if x < 0 else x ** 0.5
#     return res

# переменная res будет принимать None для отрицательных значений и квадратный корень – для неотрицательных.
# a = get_sqrt(49)
# print(a)  # 7.0


# Давайте зададим в программе еще одну функцию для определения максимального значения среди двух чисел:

# def get_max2(a, b):
#     return a if a > b else b


# x, y = 5, 7
# print(get_max2(x, y))
# 7

# Давайте теперь усложним задачу и будем искать максимум среди трех чисел. Определим три переменные и воспользуемся все той же функцией get_max2():

# x, y, z = 5, 7, 10
# print(get_max2(x,get_max2(y, z)))
# 10
# Сначала будет вызвана функция, записанная в качестве аргумента, которая возвратит максимальное среди чисел 7 и 10, то есть, значение 10, а затем, вызывается первая функция, которая определяет максимум из чисел 5 и 10. Соответственно, на выходе получаем результат 10, который и выводится в консоль.



#37. Алгоритм Евклида для нахождения НОД (наибольший общий делитель)
# (https://www.youtube.com/watch?v=IEORD_eVfCo&list=PLA0M1Bcd0w8yWHh2V70bTtbVxJICrnJHd)

# вначале пару слов о самом алгоритме Евклида, о принципе его работы. Сначала рассмотрим его медленный, но простой вариант.

# Например, пусть даны два натуральных числа: a = 18 и b = 24. Чтобы определить для них НОД, будем действовать, следующим образом. Из большего значения вычтем меньшее и результат сохраним в переменной с большим значением, то есть, в b. Фактически, это означает, что мы выполняем операцию: b = b - a. Теперь у нас два значения a = 18, b = 6. Для них повторяем тот же самый процесс. Здесь большее уже переменная a, поэтому, корректируем ее значение, вычитая меньшее. Получаем новую пару a = 12, b = 6. Опять повторяем этот процесс и видим, что a = 6, b = 6 – переменные равны. В этом случае останавливаем алгоритм и получаем, что НОД(18, 24) = 6, что, в общем то, верно.

# Весь этот алгоритм можно представить следующим псевдокодом:

# пока a != b
#          находим большее среди a и b
#          уменьшаем большее на величину меньшего

# выводим полученное значение величины a (или b)

# Давайте его опишем с помощью, следующей функции:

# def get_nod(a, b):
#     """Вычисляется НОД для натуральных чисел a и b
#         по алгоритму Евклида.
#         Возвращает вычисленный НОД.
#     """
#     while a != b:
#         if a > b:
#             a -= b
#         else:
#             b -= a

#     return a


# print(get_nod(18, 24))
# 6

# После того, как функция определена, ее следует протестировать и убедиться в корректности возвращаемых результатов. Для этого тестировщик создает свою вспомогательную функцию. Используя наши текущие знания, мы ее опишем, следующим образом:

# import time

# def test_nod(func):
    # -- тест №1 -------------------------------
    # a = 28
    # b = 35
    # res = func(a, b)
    # if res == 7:
    #     print("#test1 - ok")
    # else:
    #     print("#test1 - fail")

    # -- тест №2 -------------------------------
    # a = 100
    # b = 1
    # res = func(a, b)
    # if res == 1:
    #     print("#test2 - ok")
    # else:
    #     print("#test2 - fail")

    # # -- тест №3 -------------------------------
    # a = 2
    # b = 100000000

    # st = time.time()
    # res = func(a, b)
    # et = time.time()
    # dt = et - st
    # if res == 2 and dt < 1:
    #     print("#test3 - ok")
    # else:
    #     print("#test3 - fail")

# test_nod(get_nod)
#test1 - ok
#test2 - ok
#test3 - fail



# Смотрите, если взять два числа a = 2 и b = 100, то по изначальному алгоритму мы будем делать многочисленные вычитания из b a, пока значения не сравняются. То есть, мы здесь, фактически, вычисляем остаток от вхождения двойки в сотню, а это есть не что иное, как операция:

# b = b % a = 0

# И никаких циклических вычитаний! Это, очевидно, будет работать много быстрее. При этом, как только получаем остаток равный нулю, то НОД – это значение меньшей переменной, то есть, в нашем примере – a = 2.

# То же самое для предыдущих значений a = 18, b = 24. Получаем серию таких вычислений:

# b = 24 % 18 = 6
# a = 18 % 6 = 0

# Значит, НОД(18, 24) = 6. Видите, как это быстро и просто! На уровне псевдокода быстрый алгоритм Евклида можно описать так:

# пока меньшее число больше 0
        #  большему числу присваиваем остаток от деления на меньшее число
# выводим большее число

# Реализуем его в виде функции:

# def get_fast_nod(a, b):
#     """Вычисляется НОД для натуральных чисел a и b
#         по быстрому алгоритму Евклида.
#         Возвращает вычисленный НОД.
#     """
#     if a < b:
#         a, b = b, a

#     while b != 0:
#         a, b = b, a % b

#     return a


# test_nod(get_fast_nod)
#test1 - ok
#test2 - ok
#test3 - ok




#38. Именованные аргументы. Фактические и формальные параметры
# (https://www.youtube.com/watch?v=8Z-_PpJbkdI&list=PLA0M1Bcd0w8yWHh2V70bTtbVxJICrnJHd)

