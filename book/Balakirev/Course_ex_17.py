
# 17. Условный оператор if. Конструкция if-else
# (https://www.youtube.com/watch?v=jBP8RY2-m74&list=PLA0M1Bcd0w8yWHh2V70bTtbVxJICrnJHd&index=17)

# Инструкция if применяется для создания управляющей структуры, которая позволяет иметь в программе более одного пути исполнения. Инструкция i f исполняет одну или несколько инструкций, только когда булево выражение является истинным.

# Инструкция if-else исполняет один блок инструкций, если ее условие является истин­ным, либо другой блок, если ее условие является ложным.


# 18. Вложенные условия и множественный выбор. Конструкция if-elif-else
# (https://www.youtube.com/watch?v=7L-wetlrCi0&list=PLA0M1Bcd0w8yWHh2V70bTtbVxJICrnJHd&index=18)

# item = int(input())

# if item == 1:
#     print("выбран курс по Пайтон")
# elif item == 2:
#     print("выбран курс по C++")
# elif item == 3:
#     print("выбран курс по Java")
# elif item == 4:
#     print("выбран курс по JavaScript")
# else:
#     print("неверный пункт")


# 19. Тернарный условный оператор. Вложенное тернарное условие
# (https://www.youtube.com/watch?v=SotePVO6_Fk&list=PLA0M1Bcd0w8yWHh2V70bTtbVxJICrnJHd&index=19)

# <значение_если_истина> if <условие> else <значение_если_ложь>

# Как это работает:
# Сначала проверяется <условие>.
# Если условие истинно (True), возвращается <значение_если_истина>.
# Если ложно (False), возвращается <значение_если_ложь>.

# age = 20
# status = "Взрослый" if age >= 18 else "Ребёнок"
# print(status)  # Выведет: Взрослый


# 20. Оператор цикла while
# (https://www.youtube.com/watch?v=5BRzUFyOWYI&list=PLA0M1Bcd0w8yWHh2V70bTtbVxJICrnJHd&index=20)

# Общий формат:
# while <условие цикла>:
#     оператор1
#     оператор2
#     ...
#     операторN

# N = 100
# s = 0
# i = 1

# while i <= N:
#     s += i
#     i += 1
# print(s)  # 1050


# 21. ОПЕРАТОРЫ циклов break, continue и else
# (https://www.youtube.com/watch?v=y35dyh7cbXY&list=PLA0M1Bcd0w8yWHh2V70bTtbVxJICrnJHd&index=21)

# break - досрочное завершение цикла

# d = [1, 5, 3, 6, 0, -4]

# flFind = False
# i = 0
# while i < len(d):
#     flFind = d[i] % 2 == 0
#     if flFind:
#         print(d[i])
#         break

#     i += 1
# print(flFind)
# # 6
# # True


# continue - пропуск одной итерации цикла

# НАПРИМЕР: требуется суммировать все нечетные значения которые будет вводить пользователь. Как только будет введен 0 программа должна прекратить свою работу.

# s = 0
# d = 1

# while d != 0:
#     d = int(input("введите целое число: "))
#     if d % 2 == 0:
#         continue

#     s += d
#     print(f"Сумма нечетных значений равна {s}")


# ОПЕРАТОР else цикла while выполняется тогда и только тогда, когда происходит нормаль­ный выход из цикла (т.е. без выполнения оператора break).

# Общий формат:
# while <условие цикла>:
#     оператор1
#     оператор2
#     ...
#     операторN
# else:
# блок операторов
# после завершения
# цикла

# НАПРИМЕР:

# # s = 1/2 + 1/3 + 1/4 + ... + 1/0

# s = 0
# i = -10

# while i < 100:
#     if i == 0:
#         break
#     s += 1/i
#     i += 1
# else:
#     print("сумма вычислена корректно")

# print(s)  # -2.9289682539682538
# # блок else был пропущен, выход произошел по break
# ----------------------------------------

# поменяем условие while:
# while i < 0:
#     if i == 0:
#         break
#     s += 1/i
#     i += 1
# else:
#     print("сумма вычислена корректно")

# print(s)  # (теперь условие while выполнилось полностью и дальнейшее выполнение было передано else, и дальше на принт)
# # сумма вычислена корректно
# # -2.9289682539682538


# 22. ОПЕРАТОР цикла for. Функция range()

# Цикл for является универсальным итератором в Python: он может проходить по элементам в любой упорядоченной последовательности или в другом итерируемом объекте. Оператор for работает на строках, списках, кортежах и прочих встроенных итерируемых объектах, а также на новых объектах, определяемых пользователем, ко­торые мы позже научимся создавать с помощью классов.

# for <перемннная> in <ирерируемый объект>:    (заголовок)
#     оператор 1
#     оператор 2                               (тело цикла)
#     ...
#     оператор N

# Оператор for также поддерживает необязательный блок else, который работает точно как в цикле while — он выполняется, если выход из цикла осуществляется без помощи оператора break (т.е. когда были посещены все элементы последовательнос­ти). Представленные ранее операторы break и continue в цикле for также работают аналогично циклу while. Полный формат цикла for может быть описан следующим образом:

# for <перемннная> in <ирерируемый объект>:
#     операторы
#     if проверка: break                     # # Выход из цикла с пропуском else
#     if проверка: continue                  # Переход в начало цикла
# else:
#     операторы                              # Если не встречался оператор break

# Несколько примеров:

# d = [1, 2, 3, 4, 5]

# for x in d:
#     print(x, end=' ')
# 1 2 3 4 5

# print()
# for x in 'python':
#     print(x, end=' ')
# p y t h o n

# print()
# p = 1
# for x in d:
#     p *= x
#     print(p, end=' ')
# 1 2 6 24 120

# когда необходимо изменить сам список, то итерацию проводят по индексам списка с последующим присвоением нового значения каждому объекту итерации:
# print()

# for i in range(len(d)):
#     d[i] = 0
#     print(d)
# [0, 2, 3, 4, 5]
# [0, 0, 3, 4, 5]
# [0, 0, 0, 4, 5]
# [0, 0, 0, 0, 5]
# [0, 0, 0, 0, 0]

# ф-ия range():
# range(start, stop, step)  например: list(range(0, 5, 1))  =>  [0, 1, 2, 3, 4]
# range(start, stop)        например: list(range(0, 5))  =>  [0, 1, 2, 3, 4]
# range(stop)               например: list(range(5))  =>  [0, 1, 2, 3, 4]


# print(list(range(2)))             # [0, 1]
# print(list(range(-5)))            # []
# print(list(range(0, -5, -1)))     # [0, -1, -2, -3, -4]
# print(list(range(-10, -5)))       # [-10, -9, -8, -7, -6]
# print(list(range(-10, -5, 2)))    # [-10, -8, -6]
# print(list(range(-10, -5, -2)))   # []
# print(list(range(-10, -20, -2)))  # [-10, -12, -14, -16, -18]
# print(list(range(5, 0, -1)))      # [5, 4, 3, 2, 1]
# print(list(range(5, -1, -1)))     # [5, 4, 3, 2, 1, 0]


# 23. Примеры работы оператора цикла for. Функция enumerate()
# (https://www.youtube.com/watch?v=ycBzUTOmyVQ&list=PLA0M1Bcd0w8yWHh2V70bTtbVxJICrnJHd&index=23)

# Вычисление факториала от натурального числа:  n! = 1*2*3*...*n
# n = int(input("введите натуральное число не больше 100: "))  # пусть он ввел 10)

# if n < 0 or n > 100:
#     print("не верно введено натуральное число")
# else:
#     p = 1
#     for i in range(1, n+1):
#         p *= i
# print(f"факториал нат. числа {n} равен {p}")
# # факториал нат. числа 10 равен 3628800

# пример:
# words = ['Пайтон', 'дай', 'мне', 'силы', 'пройти', 'этот', 'курс', 'до', 'конца']
# print(' '.join(words))
# # Пайтон дай мне силы пройти этот курс до конца

# пример:
# в имеющемся списке заменить все двузначные числа нулями:
# digs = [4, 3, 100, -53, 30, 1, 34, -8]

# for i in range(len(digs)):
#     if 10 <= abs(digs[i]) <= 99:
#         digs[i] = 0

# print(digs)
# [4, 3, 100, 0, 0, 1, 0, -8]

# специальная ф-ия enumerate() возвращает пару (индекс, значение) из списка:
# теперь вышерассматриваемый пример можем переписать:
# for i, d in enumerate(digs):
#     if 10 <= abs(d) <= 99:
#         digs[i] = 0

# print(digs)
# [4, 3, 100, 0, 0, 1, 0, -8]

# еще вариант:
# for i, d in enumerate(digs):
#     if 10 <= abs(d) <= 99:
#         digs[i] += 3

# print(digs)
# [4, 3, 100, -50, 33, 1, 37, -8]


# 24. ИТЕРАТОР и итерируемые объекты. Функции iter() и next()
# (https://www.youtube.com/watch?v=Kro9UOtkZEk&list=PLA0M1Bcd0w8yWHh2V70bTtbVxJICrnJHd&index=24)

# в Python существуют объекты, содержащие последовательность некоторых элементов. Например, строки и списки. Так вот, существует универсальный механизм для перебора элементов этих и других подобных им объектов. Реализуется он через специальную конструкцию под названием итератор. То есть, каждый итерируемый объект предоставляет доступ к своим элементам через итератор. С помощью этого итератора можно один раз пройтись по всем элементам коллекции от начала до конца.

# Чтобы получить доступ к итератору объекта, например, списка, нужно вызвать специальную функцию iter() и первым аргументом указать итерируемый объект. Например, возьмем список:

# d = [5, 3, 7, 10, 32]
# print(iter(d))  # <list_iterator object at 0x0000018CC383AA40>

# чтобы перебрать значения итерируемого объекта, используется функция next(), которой следует передать объект-итератор:
# it = iter(d)
# print(next(it))  # 5

# next(it) осуществляет переход к следующему элементу (при первом вызове переходим к первому элементу) и возвращает значение этого элемента. Видим значение 5. Вызовем эту функцию еще раз:

# print(next(it))  # 3
# Итератор был перемещен на следующий элемент и возвратилось значение 3. И так можно пройтись до конца нашего списка:

# print(next(it))  # 7
# print(next(it))  # 10
# print(next(it))  # 10

# Если для последнего элемента вызвать функцию еще раз:
# print(next(it)) # StopIteration
# то получим ошибку StopIteration.
# Когда итератор дошел до конца коллекции, его уже нельзя вернуть назад и пройти все элементы заново. Для этого придется создавать новый итератор с помощью функции iter() и заново перебирать все элементы.

# Так работает этот механизм перебора элементов итерируемого объекта. Причем, он универсален и не зависит от типа объекта: это может быть и список и строка и любой другой перебираемый объект. Давайте я покажу, как это будет работать со строкой:

# s = 'python'
# Также создаем итератор:
# it_s = iter(s)
# и перебираем символы функцией next():
# print(next(it_s))  # p
# print(next(it_s))  # y
# print(next(it_s))  # t
# print(next(it_s))  # h
# print(next(it_s))  # o
# print(next(it_s))  # n

# print(next(it_s))  # StopIteration

# Как видите, итератору все равно что перебирать, главное, чтобы сам объект поддерживал этот механизм, то есть, был итерируемым. Также следует иметь в виду, что доступ к элементам через итератор и по индексу:

# print(s[2] * 5)  # ttttt

# Помимо строк и списков к итерируемым объектам также относится ранее рассмотренная функция:

# r = range(5)
# Для нее мы можем получить итератор:

# it = iter(r)
# и перебирать значения функцией next():
# print(next(it))  # 0
# print(next(it))  # 1
# print(next(it))  # 2
# print(next(it))  # 3
# print(next(it))  # 4
# print(next(it))  # StopIteration

# - если нам нужно извлечь какое-либо значение, скажем, из списка, то следует использовать индексы или срезы. То же самое и со строками. Но если нам в программе нужно перебирать итерируемые объекты самых разных типов, то единственный универсальный и безопасный способ это сделать – использовать итераторы. Например, так происходит в операторе цикла for. Мы можем ему указать перебрать любой итерируемый объект и он должен «уметь» это делать вне зависимости от типа этого объекта. Поэтому он обращается к итератору и перебирает элементы через этот универсальный механизм, пока не возникнет исключение StopIteration. Именно поэтому мы в цикле можем с легкостью перебирать и списки:

# for x in [5, 3, 7, 10, 32]:
#     print(x, end=' ')  # 5 3 7 10 32

# И строки:
# print()
# for x in 'python':
#     print(x, end=' ')  # p y t h o n

# И объект range():
# print()
# for x in range(1, 6):
#     print(x, end=' ')  # 1 2 3 4 5

# И вообще любой другой тип объектов, которые поддерживают итератор, то есть, являются итерируемыми.


# 25. ВЛОЖЕННЫЕ циклы. Примеры задач с вложенными циклами
# (https://www.youtube.com/watch?v=S5SiNuV5f7g&list=PLA0M1Bcd0w8yWHh2V70bTtbVxJICrnJHd)

# Само это название уже говорит, что один оператор цикла можно вложить в другой. Это могут быть два цикла for или два цикла while или смешанные варианты. Давайте вначале разберемся, как работают эти конструкции. Принцип у всех един, поэтому, для простоты, я возьму два цикла for (один вложен в другой). Эти циклы будут просто пробегать диапазоны чисел, первый от 1 до 3, а второй – от 1 до 5:

# for i in range(1, 4):
#     for j in range(1, 6):
#         print(f"i = {i}, j = {j}", end=' ')
#     print()
# i = 1, j = 1 i = 1, j = 2 i = 1, j = 3 i = 1, j = 4 i = 1, j = 5
# i = 2, j = 1 i = 2, j = 2 i = 2, j = 3 i = 2, j = 4 i = 2, j = 5
# i = 3, j = 1 i = 3, j = 2 i = 3, j = 3 i = 3, j = 4 i = 3, j = 5

# Во втором вложенном цикле мы будем выводить значения i и j в строку без перехода на новую строчку. А после завершения работы вложенного цикла вызовем функцию print(), как раз, для перевода курсора на новую строку. В результате выполнения этой программы, мы получим таблицу значений переменных i и j.

# Вначале у нас счетчик i принимает значение 1, а счетчик j пробегает числа от 1 до 5, в итоге получаем первую строку. После завершения вложенного цикла, срабатывает функция print() и курсор переходит на новую строку. После этого переходим ко второй итерации первого цикла и i = 2. Счетчик j снова проходит значения от 1 до 5 и получаем вторую строку. На следующей итерации первого цикла i = 3, j проходит от 1 до 5 и получаем третью строку. То есть, у нас вложенный цикл for трижды запускался заново и каждый раз j изменялось от 1 до 5. Это и есть принцип работы вложенного цикла – на каждой итерации он отрабатывает снова и снова, пока не завершится первый цикл.

# Теперь второй вопрос – зачем все это нужно? Давайте представим, что у нас есть вложенный (двумерный) список:

# a = [[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]]
# если мы будем перебирать его элементы с помощью одного оператора цикла for:

# for row in a:
#     print(row, type(row))
# 1, 2, 3, 4] <class 'list'>
# [2, 3, 4, 5] <class 'list'>
# [3, 4, 5, 6] <class 'list'>

# То переменная row будет ссылаться сначала на первый вложенный список, затем, на второй и потом на третий. Но, так как row ссылается на список, то есть, на итерируемый объект, то нам ничто не мешает перебрать его элементы с помощью второго, вложенного цикла for:

# for row in a:
#     for x in row:
#         print(x, type(x), end=' ')
#     print()
# 1 <class 'int'> 2 <class 'int'> 3 <class 'int'> 4 <class 'int'>
# 2 <class 'int'> 3 <class 'int'> 4 <class 'int'> 5 <class 'int'>
# 3 <class 'int'> 4 <class 'int'> 5 <class 'int'> 6 <class 'int'>

# а все-таки, зачем это может быть нужно? Например, так можно выполнить сложение значений из двух одинаковых двумерных списков:

# a = [[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6]]
# b = [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]]
# И сформировать на их основе третий список:
# c = []

# for i, row in enumerate(a):
#     r = []
#     for j, x in enumerate(row):
#         r.append(x + b[i][j])

#     c.append(r)
# print(c)
# [[2, 3, 4, 5], [4, 5, 6, 7], [6, 7, 8, 9]]

# Я здесь воспользовался еще одной уже знакомой нам функцией enumerate(), которая возвращает индекс и значение текущего элемента. Это удобно для реализации данной программы. Внутри первого цикла мы каждый раз создаем новый пустой список и с помощью метода append() добавляем в его конец новый элемент как сумму значений из списков a и b. Полученную строку (список r) мы, затем, добавляем в основной список c. Так вычисляется сумма значений элементов двух одинаковых списков a и b.


# #26. ТРЕУГОЛЬНИК Паскаля как пример работы вложенных циклов
# (https://www.youtube.com/watch?v=ptq-3bOwgpw&list=PLA0M1Bcd0w8yWHh2V70bTtbVxJICrnJHd)

# Этот треугольник состоит из особых чисел, которые вычисляются по правилу: по краям каждой строки стоят единицы, а каждое из остальных чисел равно сумме двух стоящих над ним из предыдущей строки (– написать программу формирования такого треугольника.)

# этот треугольник можно представить как список списков постоянно увеличивающейся длины:
# P = [[1],           # длина этой строки i
#      [1, 1],        # длина этой строки i+1
#      [1, 2, 1],     # длина этой строки i+1
#      ...
#      ]

# Далее, в программе мы запишем два вложенных цикла for со счетчиками: i – для перебора строк треугольника; j – для перебора элементов формируемой строки. Причем, j будет меняться в диапазоне [0; i]. То есть, для первой строки принимает только одно значение 0, для второй – два значения [0; 1], для третьей – три [0; 1; 2] и так далее.

# Для каждой новой (i-й) строки мы создадим список длиной i+1
# row = [1] * (i+1)

# все крайние элементы с индексами:  j == 0 or j == i   мы трогать не будем, так как там уже стоят нужные нам единицы. А все другие значения формировать на основе суммы двух предыдущих:
# row[j] = P[i-1][j-1] + P[i-1][j]

# В итоге, всю программу можно записать, так:

# N = 7
# P = []

# for i in range(0, N):
#     row = [1] * (i + 1)
#     for j in range(i + 1):
#         if j != 0 and j != i:
#             row[j] = P[i-1][j-1] + P[i-1][j]

#     P.append(row)

# for r in P:
#     print(r)
# [1]
# [1, 1]
# [1, 2, 1]
# [1, 3, 3, 1]
# [1, 4, 6, 4, 1]
# [1, 5, 10, 10, 5, 1]
# [1, 6, 15, 20, 15, 6, 1]

# Мы вначале определяем общее число строк, затем коллекцию P, которая будет хранить значения треугольника Паскаля и, далее, вложенные циклы. Первый цикл со счетчиком i перебирает строки, а второй – со счетчиком j перебирает элементы текущей строки row. Внутри вложенного цикла проверяем, если индекс j ссылается не на крайние элементы строки, то формируем их значения на основе суммы двух чисел из предыдущей строки. После этого добавляем строку в список P и проделываем эту операцию N раз. В конце программы выводим результат и давайте посмотрим, что у нас получится.

# Как видите, у нас сформировался треугольник Паскаля, состоящий из семи строк. Вот так, с помощью вложенных циклов можно решить эту, относительно несложную задачку.


# #27. ГЕНЕРАТОРЫ списков (List comprehensions)
# (https://www.youtube.com/watch?v=0QJV31Xy44o&list=PLA0M1Bcd0w8yWHh2V70bTtbVxJICrnJHd)

# познакомимся с еще одной довольно полезной и популярной конструкцией – генератором списков. По-английски это звучит как:    ( List comprehension )

# Предположим, мы хотели бы сформировать список из квадратов целых чисел от 0 до N. Используя наши текущие знания, очевидно, это можно было бы сделать, следующим образом:

# N = 6
# a = [0] * N

# for i in range(N):
#     a[i] = i ** 2

# print(a)
# [0, 1, 4, 9, 16, 25]

#  Все то же самое можно реализовать буквально в одну строчку:

# N = 6
# a = [x ** 2 for x in range(N)]

# print(a)
# [0, 1, 4, 9, 16, 25]


# Вначале мы указываем, что будем делать с переменной x. Казалось бы, переменная нигде не задана, а мы уже говорим что с ней делать. Да, это так, это такой элемент синтаксиса list comprehensions. Далее, через пробел мы записываем цикл for и уже там указываем эту переменную x и говорим как она будет меняться. То есть, эта временная переменная x существует только внутри списка и пропадает после его создания.

# Такой подход и называется генератором списков. Вначале указываем, как формируются значения списка, а затем, описываем изменение параметра x через ключевое слово for. Причем, здесь можно указывать только его. К примеру, ключевое слово while прописывать нельзя.
# Итак, для генерации списков следует придерживаться следующего синтаксиса (определения):

# [<способ формирования значения> for <переменная> in <итерируемый объект>]

# можно формировать более сложные последовательности, например, состоящих из остатков от деления на 4:

# N = 6

# a = [x % 4 for x in range(N)]
# print(a)  # [0, 1, 2, 3, 0, 1]

# То есть, мы можем использовать любые доступные нам операторы для формирования текущего значения. Если, например, взять оператор определения четного и нечетного значений:
# a = [x % 2 == 0 for x in range(N)]
# print(a)  # [True, False, True, False, True, False]

#  Или же сформировать значения линейной функции:
# a = [0.5*x+1 for x in range(N)]
# print(a)  # [1.0, 1.5, 2.0, 2.5, 3.0, 3.5]

# И так далее. Кроме того, мы здесь можем вызывать и функции. Пусть в программе пользователь вводит несколько целых чисел через пробел:

# d_inp = input("Целые числа через пробел: ")
# Тогда с помощью генератора списков мы легко можем преобразовать их в список чисел:

# a = [int(d) for d in d_inp.split()]
# print(a)  # [1, 2, 3, 4]

# Здесь конструкция d_inp.split() возвращает список строк из чисел, а функция int(d) преобразовывает каждую строку в целое число. Если убрать функцию int() и записать просто d:
# a = [d for d in d_inp.split()]
# print(a)  # ['1', '2', '3', '4']
# то у нас получился уже список из строк.


# Вообще, в генераторе списков можно использовать любые итерируемые объекты, в том числе и строки. Например, вполне допустима такая реализация:

# a = [d for d in "python"]
# print(a)  # ['p', 'y', 't', 'h', 'o', 'n']
# получим список из отдельных символов. Или, можно каждый символ превратить в его код:

# a = [ord(d) for d in "python"]
# print(a)  # [112, 121, 116, 104, 111, 110]
# Имеем список из соответствующих кодов. Если же взять список из слов:


# t = ["Я", "б", "Python", "выучил", "только", "за", "то", "что", "есть", "он", "на", "этом", "канале"]
# то генератор списка:
# a = [d for d in t]
# print(a)
# ['Я', 'б', 'Python', 'выучил', 'только', 'за', 'то', 'что', 'есть', 'он', 'на', 'этом', 'канале']
# сформирует точно такой же список. То есть, строки здесь воспринимаются уже как отдельные элементы и d ссылается на каждую из них по порядку. Я добавлю функцию len() для определения длины строк:

# a = [len(d) for d in t]
# print(a)
# [1, 1, 6, 6, 6, 2, 2, 3, 4, 2, 2, 4, 6]
# и теперь мы имеем список из длин.


# Условия в генераторах списков
# В генераторах дополнительно можно прописывать условия. Например, выберем все числа меньше нуля:

# a = [x for x in range(-5, 5) if x < 0]
# print(a)  # [-5, -4, -3, -2, -1]
# Мы здесь после оператора for записали необязательный оператор if. В результате, в список будут попадать только отрицательные значения x. Или, можно сделать проверку на нечетность:

# a = [x for x in range(-5, 5) if x % 2 != 0]
# print(a)  # [-5, -3, -1, 1, 3]
# Получаем только нечетные числа из диапазона [-5; 5). Также можно прописывать составные условия, например:

# a = [x for x in range(-6, 7) if x % 2 == 0 and x % 3 == 0]
# print(a)  # [-6, 0, 6]
# Выберем все числа, которые кратны 2 и 3 одновременно. Или, такой пример, выберем из списка городов только те, длина которых меньше семи:

# cities = ["Москва", "Тверь", "Рязань", "Ярославль", "Владимир"]
# a = [city for city in cities if len(city) < 7]
# print(a)  # ['Москва', 'Тверь', 'Рязань']
# Видите, как легко и просто можно реализовать такую задачу с помощью List comprehension.

# Ну и последнее, что я хочу отметить на этом занятии – это возможность использования тернарного условного оператора внутри генераторов списков. Так как первым элементом мы можем прописывать любые конструкции языка Python, то кто нам мешает сделать следующее. Пусть имеется список чисел:

# d = [4, 3, -5, 0, 2, 11, 122, -8, 9]
# и мы хотим преобразовать его в последовательность со словами «четное» и «нечетное». Сделать это можно как раз с помощью тернарного условного оператора:

# a = ["четное" if x % 2 == 0 else "нечетное" for x in d]
# print(a)  # ['четное', 'нечетное', 'нечетное', 'четное', 'четное', 'нечетное', 'четное', 'четное', 'нечетное']
# Обратите еще раз внимание, что этот оператор не является какой-то особой частью синтаксиса генератора списка. Мы здесь всего лишь используем его как обычный оператор языка Python. Это такой же оператор как сложение, умножение и другие:

# a = [x + 2 for x in d]
# print(a)  # [6, 5, -3, 2, 4, 13, 124, -6, 11]
# которые мы также можем использовать при формировании списков.

# Полученная запись генератора списка с тернарным оператором получилась не очень читаемой. Это можно исправить, если записать все в отдельных строчках:

# a = ["четное" if x % 2 == 0 else "нечетное"
#      for x in d
#      if x > 0]
# print(a)  # ['четное', 'нечетное', 'четное', 'нечетное', 'четное', 'нечетное']


# 28. ВЛОЖЕННЫЕ генераторы списков
# (https://www.youtube.com/watch?v=wOpKlNF7JIQ&list=PLA0M1Bcd0w8yWHh2V70bTtbVxJICrnJHd)

# На прошлом занятии мы увидели, как можно формировать списки, используя конструкции:

# [<способ формирования значения> for <счетчик> in <итерируемый объект>]
# и
# [<способ формирования значения> for <счетчик> in <итерируемый объект> if <условие>]

# в действительности, Python позволяет записывать любое число циклов for в генераторах списков. Здесь операторы if после циклов являются необязательными (мы их можем прописывать, а можем и пропускать).

# сформируем просто пары чисел в списке, следующим образом:

# a = [(i, j) for i in range(3) for j in range(4)]
# print(a)
# [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3)]

# или можно записать по другому для наглядности:

# a = [(i, j)
#      for i in range(3)
#      for j in range(4)
#      ]
# print(a)
# [(0, 0), (0, 1), (0, 2), (0, 3), (1, 0), (1, 1), (1, 2), (1, 3), (2, 0), (2, 1), (2, 2), (2, 3)]

# сначала при i = 0 отрабатывает внутренний цикл по j от 0 до 3. Затем, переходим к первому циклу, i увеличивается на 1 и внутренний цикл повторяется. В результате, получаем эти пары чисел.

# Дополнительно, мы можем указывать условия для каждого из них, например, так:

# a = [(i, j)
#      for i in range(3) if i % 3 == 0
#      for j in range(4) if j % 2 != 0
#      ]
# print(a)
# [(0, 1), (0, 3)]

# Используя этот подход, мы можем, например, сформировать таблицу умножения:

# a = [f"{i}*{j} = {i*j}"
#      for i in range(1, 4)
#      for j in range(1, 4)]
# print(a)
# ['1*1 = 1', '1*2 = 2', '1*3 = 3', '2*1 = 2', '2*2 = 4', '2*3 = 6', '3*1 = 3', '3*2 = 6', '3*3 = 9']

# Или, двумерный список превратить в одномерный:

# matrix = [[0, 1, 2, 3],
#           [10, 11, 12, 13],
#           [20, 21, 22, 23]]

# a = [x
#      for row in matrix
#      for x in row
#      ]
# print(a)
# [0, 1, 2, 3, 10, 11, 12, 13, 20, 21, 22, 23]
# мы во втором цикле используем переменную row из первого цикла. Это вполне допустимая операция, т.к. второй цикл вложен в первый и в нем доступны все переменные, объявленные ранее.


# Вложенные генераторы списков

# исходное определение генератора списка:

# [<оператор> for <счетчик> in <итерируемый объект>]

# в качестве оператора можно записывать любую конструкцию языка Python. А раз так, то кто нам мешает прописать здесь еще один генератор:

# [[генератор списка]
#    for <переменная> in <итерируемый объект>
# ]

# M, N = 3, 4
# matrix = [[a for a in range(M)] for b in range(N)]

# print(matrix)
# [[0, 1, 2], [0, 1, 2], [0, 1, 2], [0, 1, 2]]

# сначала отрабатывает первый (внешний) генератор списка и переменная b = 0. Затем, выполнение переходит к вложенному генератору, который выдает список [0, 1, 2]. Этот список помещается как первый элемент основного списка. Далее, снова отрабатывает первый генератор и b принимает значение 1. После этого переходим к вложенному генератору, который возвращает такой же список [0, 1, 2]. И так пока не закончится работа первого генератора. В итоге, видим список, в который вложены четыре других списка.

# Где может пригодиться такой подход? Например, для изменения значений двумерного списка. Давайте предположим, что у нас есть вот такой список:

A = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
print(A)
# [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# И мы хотим возвести все его значения в квадрат. Лучше всего это сделать именно через генератор, следующим образом:

A = [[x ** 2 for x in row] for row in A]
print(A)
# [[1, 4, 9], [16, 25, 36], [49, 64, 81]]

# В первом генераторе происходит перебор строк (вложенных списков) матрицы A, а во вложенном генераторе – обход элементов строк матрицы. Каждое значение возводится в квадрат и на основе этого формируется текущая строка. Обратите внимание, что во вложении мы можем использовать переменные из внешнего генератора списка, в частности, переменную row, ссылающуюся на текущую строку матрицы A.

# Другой пример – это транспонирование матрицы A (то есть, замена строк на столбцы) с использованием вложенных генераторов. Сделать это можно, следующим образом:

A = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
A = [[row[i] for row in A] for i in range(len(A[0]))]
print(A)
# [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]]

# Сначала значение i = 0, а переменная row[i] пробегает первые значения строк матрицы A. В результате формируется первая строка транспонированной матрицы. Далее, i увеличивается на 1 и row[i] пробегает уже вторые элементы строк матрицы A. Получаем вторую строку транспонированной матрицы. И так делаем для всех столбцов. На выходе формируется транспонированная матрица.

# Другой вариант, когда мы список помещаем в качестве итерируемого объекта. Да, сам по себе генератор списка поддерживает механизм итерирования – перебора элементов через итератор, поэтому может быть использован в операторе for, например, так:

g = [u ** 2 for u in [x+1 for x in range(5)]]
print(g)
# [1, 4, 9, 16, 25]

# 3десь сначала отрабатывает вложенный генератор списка, получаем список [1, 2, 3, 4, 5], а затем, эти значения перебираются первым генератором и возводятся в квадрат, получаем результат:
