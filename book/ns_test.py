# Для тестирования чего-то непонятного


# Задание 1
# Напишите класс MusicAlbum, у которого есть: Атрибуты title, artist, release_year, genre, tracklist (название, исполнитель, год выхода, жанр, список треков. Метод play_random_track() для вывода случайного названия песни.

# import random


# class MusicAlbum:
#     def __init__(self, title, artist, release_year, genre, tracklist):
#         """
#         Инициализация атрибутов альбома.

#         :param title: Название альбома
#         :param artist: Исполнитель
#         :param release_year: Год выпуска
#         :param genre: Жанр
#         :param tracklist: Список треков (список словарей c названием, исполнителем и годом выхода)
#         """
#         self.title = title
#         self.artist = artist
#         self.release_year = release_year
#         self.genre = genre
#         self.tracklist = tracklist

#     def play_random_track(self):
#         """
#         Метод для воспроизведения случайного трека из списка треков альбома.
#         """
#         random_track = random.choice(self.tracklist)
#         print(
#             f"Сейчас играется: '{random_track['title']}' — {random_track['artist']} ({random_track['release_year']}, Жанр: {random_track['genre']})")


# # Пример использования класса
# if __name__ == '__main__':
#     album_title = "Thriller"
#     album_artist = "Michael Jackson"
#     album_release_year = 1982
#     album_genre = "Pop"
#     album_tracklist = [
#         {"title": "Wanna Be Startin' Somethin'", "artist": "Michael Jackson",
#             "release_year": 1982, "genre": "Pop"},
#         {"title": "Baby Be Mine", "artist": "Michael Jackson",
#             "release_year": 1982, "genre": "Pop"},
#         {"title": "The Girl Is Mine", "artist": "Michael Jackson",
#             "release_year": 1982, "genre": "Pop"},
#         {"title": "Thriller", "artist": "Michael Jackson",
#             "release_year": 1982, "genre": "Pop"},
#         {"title": "Beat It", "artist": "Michael Jackson",
#             "release_year": 1982, "genre": "Pop"},
#         {"title": "Billie Jean", "artist": "Michael Jackson",
#             "release_year": 1982, "genre": "Pop"},
#         {"title": "Human Nature", "artist": "Michael Jackson",
#             "release_year": 1982, "genre": "Pop"},
#         {"title": "P.Y.T. (Pretty Young Thing)", "artist": "Michael Jackson",
#          "release_year": 1982, "genre": "Pop"},
#         {"title": "The Lady in My Life", "artist": "Michael Jackson",
#             "release_year": 1982, "genre": "Pop"}
#     ]

#     album = MusicAlbum(album_title, album_artist,
#                        album_release_year, album_genre, album_tracklist)

#     # Воспроизводим случайный трек
#     album.play_random_track()

# -----------------------------------------------------------------------------------

# Программирование на Python с нуля за 8 часов (https://www.youtube.com/watch?v=jFgBUu3Bqas)

# Раздел: Введение в ООП.

# class Animal:
#     name = 'No Name'
#     age = 0
#     fed = False

#     count = 0
#     lst = []

#     def __init__(self, name, age, fed):
#         self.name = name
#         self.age = age
#         self.fed = fed
#         Animal.count += 1             # ведём подсчёт животных
#         Animal.lst.append(self.name)  # добавляем имена в список lst[]

#     def feed(self):
#         if not self.fed:
#             self.fed = True


# cat1 = Animal('Barsic', 3, True)
# cat2 = Animal('Gopen', 2, False)

# cat2.feed()     # покормим cat2, ведь он изначально не кормлен (False)
# print(cat2.fed) # принт показывает, что теперь пакормлен

# print(Animal.count)
# print(Animal.lst)

# --------------------------------------------------------------------------------

# Задание 1
# Напишите функцию для вывода треугольника. Функция принимает два аргумента – size (размер сторон треугольника) и symb (символ, используемый для заполнения треугольника).

# def drow_triangl(sise, symb):
#     for i in range(1, sise + 1):
#         print(symb * min(i, sise + 1 - i))


# sise = int(input('Введите размер: '))
# symb = input('Введите символ: ')
# drow_triangl(sise, symb)

# Задание 2
# Напишите функцию, которая принимает произвольное количество целых чисел, и возвращает среднее арифметическое без использования встроенных функции sum() и len().

# def arithmetic_average(args):
#     total_vol = 0
#     for vol in args:
#         total_vol += vol
#     return total_vol / len(args)


# args = [5, 8, 3, 9, 7, 10]
# print(arithmetic_average(args))
# # 7.0
# ------------------------------------------------------------------

# data = [2.71, 3.14, 1.41, 1.62]

# data.remove(2.71)
# last = data.pop()
# print(data)
# print(last)


# my_list = [5, 8, 10, 16, 11, 18, 4]
# # a = len(my_list[2:])

# # print(a)
# min_num = min(my_list)
# print(min_num)
# max_num = max(my_list)
# print(max_num)


# Доступ к значению элемента словаря с помощью переменной:

# my_motorbike = {
#     'brand': 'Ducati',
#     'price': 25000,
#     'engine_vol': 1.2,
# }
# a = 'brand'

# my_motorbike[a] = 'BMW'
# print(my_motorbike)  # {'brand': 'BMW', 'price': 25000, 'engine_vol': 1.2}
# -----------------------------------------------------------------------------

# ПАЙТОН ОТ ЛУТЦА (строки)

# s = 'Spam'
# print(len(s))       # 4
# print(s)            # Spam
# print(s[0])         # S
# print(s[-1])        # m
# print(s[len(s) - 1])  # m

# вы не сумеете изменить строку, присваивая значение символу в одной из ее позиций, но всегда сможете построить новую строку и назначить ей то же самое имя:

# s[0] = 'z'  # выдает ошибку
# зато мы можем выполнять выражения для создания новых объектов:

# print('z' + s[1:])  # zpam


# s = 'shrubbery'
# l = list(s)  # развернуть в список
# print(l)  # ['s', 'h', 'r', 'u', 'b', 'b', 'e', 'r', 'y']

# l[1] = 'c'
# print(l)  # ['s', 'c', 'r', 'u', 'b', 'b', 'e', 'r', 'y']
# print(''.join(l))  # объединение с пустым разддклителем
# # scrubbery


# Методы, специфичные для типа

# Например, строковый метод find представляет собой операцию поиска подстро­ки (она возвращает смещение указанной подстроки или -1, если подстрока не найде­на), а строковый метод replace выполняет глобальный поиск и замену; оба метода действуют на объекте, к которому они присоединены и вызваны:

# s = 'shrubbery'
# print(s.find('bb'))  # 4  (смещение подстроки)
# print(s.find('ru'))  # 2  (смещение подстроки)
# print(s.find('ay'))  # -1  (подстрока не найдена)
# ---------------------------------------

# s = 'shrubberuy'
# print(s.replace('ru', 'XYZ'))  # shXYZbbeXYZy (замена вхождений подстроки другой подстрокой)

# эти методы не изменяют исходные строки, а создают в качестве результатов новые строки — из-за того, что строки неизменяемы, методы могут работать только таким способом.
# другие методы разбивают строку на подстроки по разделителю (удобны как простая форма разбора), выполняют преоб­разования регистра символов, проверяют содержимое строки (цифры, буквы и т.д.) и удаляют пробельные символы из концов строки:

# line = 'aaa,bbb,cc,dddd'
# print(line.split(','))  # разбить по разделителю в список подстрок
# # ['aaa', 'bbb', 'cc', 'dddd']
# s = 'shrubbery'
# print(s.upper())  # преобразовать в верхний регистр
# # SHRUBBERY
# print(s.isalpha())  # Проверить содержимое: isalpha, isdigit и т.д....
# # True
# ------------------------------------------------

# line = 'aaa,bbb,cc,dddd\n'
# print(line.rstrip())  # удалить пробельные символы справа
# # aaa,bbb,cc,dddd
# print(line.rstrip().rsplit(','))  # скомбинировать две операции
# # ['aaa', 'bbb', 'cc', 'dddd']

# Взгляните на последнюю команду — она удаляет пробельные символы до того, как раз­бивает строку, потому что Python выполняет операции слева направо, попутно создавая временный результат.
# ------------------------------------------------

# Строки также поддерживают более сложную операцию подстанов­ки, известную как форматирование.

# print("{}, aggs, and {} ".format('spam', 'SPAM!'))
# # spam, aggs, and SPAM!


# Получение справки:

#  Для получения дополнительных деталей вы всегда можете вызвать встроенную функцию dir. Когда функция dir вы­зывается без аргументов, она выводит список переменных, присвоенных в области видимости вызывающего объекта. Более полезно то, что функция dir возвращает список всех атрибутов, доступных для любого переданного ей объекта.
# Функция dir просто выдает имена методов. Чтобы выяснить, что делает тот или иной метод, его имя можно передать функции help.


# СПИСКИ

#  Списки представляют собой позиционно упорядоченные коллекции объектов произвольных типов и не имеют фиксированных размеров. Кроме того, они изменяе­мы — в отличие от строк списки можно модифицировать на месте путем присваивания по смещениям и вызова разнообразных списковых методов. Соответственно они пре­доставляют очень гибкий инструмент для представления произвольных коллекций перечня файлов в каталоге, сотрудников в компании, сообщений в ящике входящей почты и т.д.

# Операции над последовательностями

# Будучи последовательностями, списки поддерживают все операции над последовательностями, которые мы обсуждали для строк; единственное отличие в том, что результатами обычно будут не строки, а списки. Например, имея список из трех элементов:

# Список из трех объектов разных типов:
# a = [123, 'Spam', 1.23]
# print(len(a))  # 3

# мы можем его индексировать, нарезать и выполнять другие действия в точности, как поступали со строками:
# print(a[0])  # 123 (индексация по позиции)

# Нарезание списка возвращает новый список:
# print(a[:-1])  # [123, 'Spam']
# print(a + [4, 5, 6])  # [123, 'Spam', 1.23, 4, 5, 6]
# print(a * 2)  # [123, 'Spam', 1.23, 123, 'Spam', 1.23]

# print(a)  # [123, 'Spam', 1.23]  (исходный список не изменился)


# Операции, специфичные для типа

# списки не имеют фиксированных размеров. То есть они могут увеличиваться и уменьшаться в ответ на операции, специфичные для списков:
# a = [123, 'Spam', 1.23]

# Увеличение: добавление объекта в конец списка:
# a.append('Ni')
# print(a)  # [123, 'Spam', 1.23, 'Ni']

# Уменьшение: удаление элемента из середины:
# a.pop(2)
# print(a)  # [123, 'Spam', 'Ni'] (del a[2] также выполняет удаление из списка)

# del a[0]
# print(a)  # ['Spam', 'Ni']

# Списковый метод append увеличивает размер списка и помещает объект в конец; метод pop (или эквивалентный оператор del) удаляет элемент по заданному смещению, приводя к уменьшению списка. Другие списковые методы вставляют объект в произвольную позицию (insert), удаляют указанный элемент по значению (remove), добавляют множество элементов в конец (extend) и т.д. Поскольку списки являются изменяемыми, большинство списковых методов также модифицируют объект списка на месте, а не создают новый такой объект:

# m = ['bb', 'aa', 'cc']
# m.sort()
# print(m)  # ['aa', 'bb', 'cc']

# m.reverse()
# print(m)  # ['cc', 'bb', 'aa']
# метод sort по умолчанию упорядочивает список по возрастанию, а метод reverse обращает его — в обоих случаях методы модифицируют список напрямую.

# ВЛОЖЕНИЕ
# особенность основных типов данных Python заключается в том, что они поддерживают произвольное вложение — мы можем вкладывать их в любой комбинации и на любую желаемую глубину.
# Список с вложенными списками:
# m = [[1,2,3],       # Матрица 3 х 3 в виде вложенных списков
#      [4,5,6],
#      [7,8,9]]
# print(m)    # [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

# Доступ к такой структуре может осуществляться разнообразными способами:
# получить строку 2:
# print(m[1])  # [4, 5, 6]

# # Получить строку 2 и затем элемент 3 внутри этой строки:
# print(m[1][2])  # 6

# Первая операция извлекает вторую строку целиком, а вторая — третий элемент данной строки (она выполняется слева направо, как ранее применявшиеся операции strip и split для строк). Увязывание вместе операций индексации позволяет нам перемещаться все глубже и глубже в структуру вложенных объектов.


# СПИСКОВЫЕ ВКЛЮЧЕНИЯ

# В дополнение к операциям над последовательностями и списковым методам в Python имеется более сложная операция, известная как выражение спискового включения (list comprehension), которая оказывается мощным способом обработки структур, подобных нашей матрице. Предположим, например, что необходимо извлечь второй столбец из матрицы. Получать строки легко посредством простой индексации, потому что матрица хранится по строкам, но получить столбец почти так же легко с помощью спискового включения:

# m = [[1, 2, 3],       # Матрица 3 х 3 в виде вложенных списков
#      [4, 5, 6],
#      [7, 8, 9]]
# # Собрать элементы в столбце 2:  (column - столбец, row - ряд)
# column_2 = [row[1] for row in m]
# print(column_2)  # [2, 5, 8]
# # [[1, 2, 3], [4, 5, 6], [7, 8, 9]]  (исходная матрица не изменилась)
# print(m)

# - это списковое включение означает “предоставить row [1] из каждой строки матрицы М в новом списке”. Результатом будет новый список, содержащий столбец 2 матрицы.
# На практике списковые включения могут быть более сложными:

# Добавить 1 к каждому элементу во втором столбце:
# column_2 = [row[1] + 1 for row in m]
# print(column_2)  # [3, 6, 9]

# Отфильтровать нечетные элементы:
# column = [row[1] for row in m if row[1] % 2 == 0]
# print(column)  # [2, 8]

# Собрать диагональ из матрицы:
# (списковые включения применяются для прохода по жестко закодированному списку координат и по строке)
# diag = [m[i][i] for i in [0, 1, 2]]
# print(diag)  # [1, 5, 9]

# Повторить символы в строке:
# doubles = [c * 2 for c in 'Spam']
# print(doubles)  # ['SS', 'pp', 'aa', 'mm']


# Ниже демонстрируется применение range — встроенной функции, которая генерирует последовательные целые числа и в Python З.Х для отображения всех своих значений требует наличия окружающего вызова list:

# print(list(range(4)))  # [0, 1, 2, 3]
# print(list(range(-6, 7, 2)))  # [-6, -4, -2, 0, 2, 4, 6] (от -6 до +6 с шагом 2)

# print([[x ** 2, x ** 3] for x in range(4)])  # [[0, 0], [1, 1], [4, 8], [9, 27]]

# print([[x, x // 2, x * 2]
#        for x in range(-6, 7, 2)
#        if x > 0])                             # [[2, 1, 4], [4, 2, 8], [6, 3, 12]]

#  помещая списковое включение в круглые скобки, можно создавать генераторы, которые производят результаты по требованию. В целях иллюстрации встроенная функция sum суммирует элементы в последовательности; вот пример суммирования всех элементов в строках нашей матрицы по требованию: (next()):
# m = [[1, 2, 3],       # Матрица 3 х 3 в виде вложенных списков
#      [4, 5, 6],
#      [7, 8, 9]]
# g = (sum(row) for row in m)
# Запустить протокол итерации next ():
# print(next(g))  # 6
# print(next(g))  # 15
# print(next(g))  # 24

#  Встроенная функция mар() способна выполнять похожую работу, генерируя результаты прогона элементов через функцию, по одному за раз по запросу (next()). Подобно range ее помещение внутрь вызова list приводит к возвращению всех значений:
# m = [[1, 2, 3],       # Матрица 3 х 3 в виде вложенных списков
#      [4, 5, 6],
#      [7, 8, 9]]
# print(next(map(sum, m)))  # 6
# print(next(map(sum, m)))  # 6
# print(next(map(sum, m)))  # 6

# print(list(map(sum, m)))  # [6, 15, 24]

#  синтаксис списковых включений можно также использовать для создания множеств и словарей':

# - cоздать множество сумм элементов в строках:
# print({sum(row) for row in m})  # {24, 6, 15} (расположение эл-ов произвольное)

# Создать (словарь) таблицу ключей/значений сумм элементов в строках для матрицы m:
# print({i: sum(m[i]) for i in range(3)})  # {0: 6, 1: 15, 2: 24}

# в самом деле в Python З.Х и 2.7 списки, множества, словари и генераторы могут быть простроены с помощью списковых включений:
# Список порядковых чисел для символов:
# print([ord(x) for x in 'spaam'])  # [115, 112, 97, 97, 109]

# Множество с удаленными дубликатами: (произвольный порядок)
# print({ord(x) for x in 'spaam'})  # {112, 97, 115, 109}

# Словарь с уникальными ключами:
# print({x: ord(x) for x in 'spaam'})  # {'s': 115, 'p': 112, 'a': 97, 'm': 109}

# Генератор значений:
# g = ((ord(x) for x in 'spaam'))  # <generator object <genexpr> at 0x000002A21D13B2A0>
# print(next(g))  # 115
# print(next(g))  # 112
# print(next(g))  # 97
# print(next(g))  # 97
# print(next(g))  # 109


# СЛОВАРИ

# d = {'food': 'Spam', 'quantity': 4, 'color': 'pink'}
# Операция индексации словаря имеет такой же синтак­сис, как для последовательностей, но элементом в квадратных скобках будет ключ, а не относительная позиция:

# Извлечь значение, связанное с ключом 'food':
# print(d['food'])  # Spam

# Добавить 1 к значению, связанному с ключом 'quantity':
# d['quantity'] += 1
# print(d)  # {'food': 'Spam', 'quantity': 5, 'color': 'pink'}

# следующий код начинает с пустого словаря и заполня­ет его по одному ключу за раз:
# b = {}
# b['name'] = 'Bob'       # Присваивание приводит к созданию ключей
# b['job'] = 'dev'
# b['age'] = 40
# print(b)  # {'name': 'Bob', 'job': 'dev', 'age': 40}

# можно создать словарь по другому (используя метод dict()):
# a = dict(name='Bob', job='dev', age=40)
# print(a)  # {'name': 'Bob', 'job': 'dev', 'age': 40}

# создать словарь из двух списков с помощью методов dict() и zip():
# my_list_1 = ['name', 'job', 'age']  # будующие ключи
# my_list_2 = ['Bob', 'dev', 40]      # будующие значения
# c = dict(zip(my_list_1, my_list_2))
# print(c)  # {'name': 'Bob', 'job': 'dev', 'age': 40}
# Отображения не являются позиционно упорядоченными, поэтому (если толь­ко вам не повезет) они возвратятся в порядке, отличающемся от того, в котором вы их набирали. Точный порядок может варьироваться в зависимости от версии Python, но вы не должны на него полагаться.


# Снова о вложении:
# Пусть нам нужно хранить имя и фамилию и несколько названий должностей. В итогемы имеем еще одно применение вложения объектов Python в действии. В приведен­ном далее словаре, одновременно представленном в виде литерала, содержится более структурированная информация:
# rec = {'name':{'first': 'Bob', 'last': 'Smith'},
#        'jobs': ['dev', 'mgr'],
#        'age': 40.5}
# Мы можем получать доступ к компонентам этой струк­туры почти так же, как ранее к матрице, основанной на списках, но теперь большинс­тво индексов являются ключами в словарях, а не смещениями в списках:
# print(rec['name'])  # {'first': 'Bob', 'last': 'Smith'}
# print(rec['name']['last'])  # Smith

# print(rec['jobs'])  # ['dev', 'mgr']
# print(rec['jobs'][-1])  # mgr

# rec['jobs'].append('janitor')
# print(rec)  # {'name': {'first': 'Bob', 'last': 'Smith'}, 'jobs': ['dev', 'mgr', 'janitor'], 'age': 40.5}
# последняя операция расширяет вложенный список названий должностей — поскольку список находится в области памяти, отдельной от словаря, который его содержит, он может свободно увеличиваться и уменьшаться.


# Недостающие ключи: проверки if
# d = {'a': 1, 'b': 2, 'c': 3}
# print(d)  #{'a': 1, 'b': 2, 'c': 3}

# d['e'] = 99  # Присваивание новому ключу увеличивает словари
# print(d)  #{'a': 1, 'b': 2, 'c': 3, 'e': 99}

# Ссылка на несуществующий ключ приводит к ошибке:
# d['f']
# print(d)  # KeyError: 'f'
# Одно из реше­ний предусматривает заблаговременную проверку. Выражение проверки членства в словаре, in, позволяет запрашивать существование ключа и организовать ветвление в зависимости от результата с помощью Python-оператора if.

# if not 'f' in d:
#     print('missing')
# missing
# Кроме проверки посредством in существует еще много других способов избежать обращения к несуществующим ключам в создаваемых словарях: метод get(условный индекс со стандартным вариантом):

# value = d.get('f', 0)
# print(value)
# 0  (возвращает (в случае отсутствия ключа) значение по умолчанию (0). Этим значением может быть "сообшение, что ключ не найден".


# СОРТИРОВКА ключей: циклы for

# Как упоминалось ранее, поскольку словари — не последовательности, они не под­ держивают сколько-нибудь надежный порядок слева направо. Если создать словарь и сразу его вывести, то ключи могут следовать не в том порядке, в котором они набира­лись, и варьироваться в зависимости от версии Python и других переменных:

# d = {'a': 1, 'b': 2, 'c': 3}
# print(d)  #{'a': 1, 'b': 2, 'c': 3}
# что делать, если необходимо навязать какой-то порядок элементам слова­ря? Распространенное решение предусматривает получение списка ключей с помо­щью метода keys словаря, сортировку этого списка посредством спискового метода sort и проход по результату в цикле for языка Python:

# ks = list(d.keys())  # Неупорядоченный список ключей (он может быть произвольным)
# print(ks)  # ['a', 'b', 'c']
# ks.sort()            # Отсортированный список ключей
# print(ks)  # ['a', 'b', 'c']

# for key in ks:
#     print(key, '==>', d[key])
# a ==> 1
# b ==> 2
# c ==> 3

# Процесс состоит их трех шагов, хотя, как вы увидите далее в книге, в последних версиях Python задачу можно решить за один шаг посредством новой встроенной фун­кции sorted. Вызов sorted возвращает результат и сортирует объекты разнообраз­ных типов, в данном случае сортируя ключи словаря автоматически:

# for key in sorted(d):
#     print(key, '==>', d[key])
# a ==> 1
# b ==> 2
# c ==> 3

# Например, вот как можно пройти по символам в строке с выводом их версии в верхнем регистре:
# for c in 'spam':
#     print(c.upper(), end=' ')
# S P A M

# Цикл while языка Python представляет собой более универсальную разновидность инструментов для организации циклов; он не ограничивается проходом через после­ довательности, но в целом требует написания большего объема кода:
# x = 4
# while x > 0:
#     print('spam ' * x)
#     x -= 1
# spam spam spam spam
# spam spam spam
# spam spam
# spam

# x = 1
# while x <= 4:
#     print('spam ' * x)
#     x += 1
# spam
# spam spam
# spam spam spam
# spam spam spam spam


# КОРТЕЖИ:
# Объект кортежа примерно похож на список, который нельзя изменять — кортежи являются последовательностями подобно спискам, но они неизменяемые подобно строка­м. Функционально они используются для представления фиксированных коллекций элементов: скажем, компонентов специфической даты в календаре. Синтаксически они записываются в круглых, а не квадратных скобках и поддерживают произвольные типы, произвольное вложение и обычные операции над последовательностями:

# t = (1, 2, 3, 4)
# print(len(t))  # 4

# print(t + (5, 6))  # (1, 2, 3, 4, 5, 6) - конкатенация
# print(t[0])  # 1  - индексция, нарезка и тд

# Кортежи в Python 2.6 и 3.0 также имеют вызываемые методы, специфичные для типа, но далеко не так много, как списки:
# print(t.index(4))  # 3  (Методы кортежей: 4 обнаруживается по смещению 3)
# print(t.count(4))  # 1  (4 обнаруживается один раз)

# Главное отличие кортежей заключается в том, что после создания их нельзя из­ менять, т.е. они являются неизменяемыми последовательностями (одноэлементные кортежи вроде приведенного ниже требуют хвостовой запятой):
# например:
# t[0] = 2  # Ошибка типа: объект tuple не поддерживает присваивание в отношении элементов (Кортежи не изменяемы)
# но зато можно создать новый кортеж для нового значения:
# t = (2,) + t[1:]
# print(t)  # (2, 2, 3, 4)

# Подобно спискам и словарям кортежи поддерживают смешанные типы и вложе­ние, но не увеличиваются и не уменьшаются, поскольку они неизменяемы (круглые скобки, окружающие элементы кортежа, часто можно опускать, как сделано здесь; за­пятые — это то, что фактически строит кортеж):
# t = 'spam', 3.0, [11, 22, 33,]  # без круглых скобок это тоже кортеж
# print(t)  # ('spam', 3.0, [11, 22, 33])
# print(t[1])  # 3.0
# print(t[2][1])  # 22

# t.append(4)  # Ошибка атрибута: объект tuple не имеет атрибута append.
# Итак, зачем нам тип, который похож на список, но поддерживает меньше опера­ций? Откровенно говоря, на практике кортежи применяются в целом не так часто, как списки, но весь смысл в их неизменяемости. Если вы передаете коллекцию объек­тов внутри своей программы в виде списка, тогда он может быть модифицирован где угодно; если вы используете кортеж, то изменить его не удастся. То есть кортежи обес­печивают своего рода ограничение целостности, что удобно в программах, крупнеетех, которые мы будем писать здесь.


# ФАЙЛЫ:

# Объекты файлов являются главным интерфейсом к внешним файлам на компью­тере. Они могут применяться для чтения и записи текстовых заметок, аудиоклипов, документов Excel, сохраненных сообщений электронной почты и всего того, что вы в итоге сохранили на своем компьютере. Файлы относятся к основным типам, но они кое в чем своеобразны — специфический литеральный синтаксис для их создания от­сутствует, Взамен, чтобы создать объект файла, необходимо вызвать встроенную фун­кцию open, передав ей в виде строк имя внешнего файла и необязательный режим обработки.
# Например, для создания выходного текстового файла понадобится передать его имя и строку режима обработки (w), чтобы записывать данные:
# f = open('data.txt', 'w')  # Создать новый файл в режиме записи ('w')
# print(f.write('Hello\n'))  # Записать в него строку символов и возвратить количество записанных элементов
# # 6
# print(f.write('World\n'))  # Возвратить количество записанных элементов
# # 6
# f.close()  # # Закрыть для сбрасывания буферов вывода на диск

# Код создает файл в текущем каталоге и записывает в него текст (имя файла мо­жет содержать полный путь к каталогу, если нужно получить доступ к файлу где-то в другом месте на компьютере). Чтобы прочитать то, что было записано, необходимо повторно открыть файл в режиме обработки ’ г ’ для чтения текстового ввода (он вы­ бирается по умолчанию, если в вызове строка режима не указана). Затем следует про­читать содержимое файла в строку и отобразить ее. В сценарии содержимое файла всегда будет строкой независимо от типа находящихся в нем данных:
# f = open('data.txt')  # 'г' (чтение) - стандартный режим обработки
# text = f.read()       # Прочитать все содержимое файла в строку
# # 'Hello\nWorld\n'
# print(text)           # print интерпретирует управляющие символы
# # Hello
# # World
# print(text.split())   # Содержимое файла - всегда строка
# # ['Hello', 'World']

# МНОЖЕСТВА:

