# ОБЪЕКТНО-ОРИЕНТИРОВАННОЕ ПРОГРАММИРОВАНИЕ

# КЛАССЫ И ОБЪЕКТЫ

# Класс представляет некоторую сущность. Конкретным воплощением класса является объект.
# В языке Python класс определяется с помощью ключевого слова class:

# class название_класса:
#     атрибуты_класса
#     методы_класса

# Внутри класса определяются его атрибуты, которые хранят различные характеристики класса, и методы - функции класса.

# Создадим простейший класс:

# class Person:
#     pass

# оператор pass применяется, когда синтаксически необходимо определить некоторый код, однако исходя из задачи код нам не нужен, и вместо конкретного кода вставляем оператор pass.

# После создания класса можно определить объекты этого класса. Например:

# class Person:
#     pass

# tom = Person()       # определение объекта tom
# bob = Person()       # определение объекта bob

# После определения класса Person создаются два объекта класса Person - tom и bob. Для создания объекта применяется специальная функция - конструктор, которая называется по имени класса и которая возвращает объект класса. То есть в данном случае вызов Person() представляет вызов конструктора. Каждый класс по умолчанию имеет конструктор без параметров:

# tom = Person()      # Person() - вызов конструктора, который возвращает объект класса Person

# КОНСТРУКТОР

# Итак, для создания объекта класса используется конструктор. Так, когда мы создавали объекты класса Person, мы использовали конструктор по умолчанию, который не принимает параметров и который неявно имеют все классы. ОДНАКО МЫ МОЖЕМ И ЯВНЫМ образом определить в классах конструктор с помощью специального метода, который называется __init__() (по два прочерка с каждой стороны):

# class Person:
#     # конструктор
#     def __init__(self):
#         print("Создание объекта Person")

# tom = Person()      # Создание объекта Person

# Итак, здесь в коде класса Person определен конструктор - функция __init__. Конструктор должен принимать как минимум один параметр ссылку на текущий объект - self. Обычно конструкторы применяются для определения действий, которые должны производиться при создании объекта.

# Теперь при создании объекта:
# tom = Person()
# выполняется вызов конструктора __init__() из класса Person, который выведет на консоль строку "Создание объекта Person".

# Стоит отметить, что конструктор фактически представляет обычную функцию, только для вызовы конструктора используется не __init__, а название класса. Кроме того, при вызове конструктора параметру self явным образом не передается никакого значения. При выполнении программы Python динамически будет определять self.

# АТРИБУТЫ ОБЪЕКТА

# Атрибуты хранят состояние объекта. Для определения атрибутов внутри класса применяют self. Например, определим следующий класс Person:

# class Person:

#     def __init__(self, name, age):
#         self.name = name    # атрибут - имя человека
#         self.age = age      # атрибут - возраст человека


# tom = Person("Tom", 22)

# # обращение к атрибутам
# # получение значений
# print(tom.name)      # Tom
# print(tom.age)       # 22
# # изменение значения
# tom.age = 37
# print(tom.age)       # 37

# Теперь конструктор класса Person принимает два параметра - name и age. Через эти параметры в конструктор будут передаваться имя и возраст создаваемого человека.

# Внутри конструктора устанавливаются два атрибута - name и age:

# def __init__(self, name, age):
#     self.name = name
#     self.age = age

# Атрибуту self.name присваивается значение переменной name. Атрибуту self.age присваивается значение переменной age. Название атрибутов не обязательно должно соответствовать названиям параметров.

# Если мы определили в классе конструктор __init__ с параметрами (кроме self), то при вызове конструктора этим параметрам надо передать значения:

# tom = Person("Tom", 22)

# То есть в данном случае параметру name передается строка "Tom", а параметру age - число 22.
# Далее по имени объекта мы можем обращаться к атрибутам объекта - получать и изменять их значения:

# print(tom.name)     # получение значения атрибута name
# tom.age = 37        # изменение значения атрибута age

# Подобным образом мы можем создавать разные объекты класса Person с разным значением для атрибутов:

# class Person:

#     def __init__(self, name, age):
#         self.name = name    # имя человека
#         self.age = age      # возраст человека


# tom = Person("Tom", 22)
# bob = Person("Bob", 43)

# print(tom.name)      # Tom
# print(bob.name)      # Bob

# Здесь создаются два объекта класса Person: tom и bob. Они соответствуют определению класса Person, имеют одинаковый набор атрибутов, однако их состояние будет отличаться. И в каждом случае Python будет динамически определять объект self. Так, в следующем случае

# tom = Person("Tom", 22)
# Это будет объект tom
# А при вызове

# bob = Person("Bob", 43)
# Это будет объект bob

# В принципе нам необязательно определять атрибуты внутри класса - Python позволяет сделать это динамически вне кода:

# class Person:

#     def __init__(self, name, age):
#         self.name = name     # имя человека
#         self.age = age       # возраст человека


# tom = Person("Tom", 22)

# tom.company = "Microsoft"
# print(tom.company)  # Microsoft

# Здесь динамически устанавливается атрибут company, который хранит место работы человека. И после установки мы также можем получить его значение. В то же время подобное определение чревато ошибками. Например, если мы попытаемся обратиться к атрибуту до его определения, то программа сгенерирует ошибку:

# tom = Person("Tom", 22)
# print(tom.company)  # ! Ошибка - AttributeError: Person object has no attribute company


# МЕТОДЫ КЛАССОВ

# Методы класса фактически представляют функции, которые определенны внутри класса и которые определяют его поведение. Например, определим класс Person с одним методом:

# class Person:    # определение класса Person
#     def say_hello(self):  # метод say_hello()
#         print("Hello")

# tom = Person()
# tom.say_hello()    # Hello

# При определении методов любого класса, как и конструктора, первый параметр метода представляет ссылку на текущий объект, который согласно условностям называется self. Через эту ссылку внутри класса мы можем обратиться к функциональности текущего объекта. Но при самом вызове метода этот параметр не учитывается.

# Используя имя объекта, мы можем обратиться к его методам. Для обращения к методам применяется нотация точки - после имени объекта ставится точка и после нее идет вызов метода:

# объект.метод([параметры метода])

# tom.say_hello()    # Hello
# В итоге данная программа выведет на консоль строку "Hello".

# Если метод должен принимать другие параметры, то они определяются после параметра self, и при вызове подобного метода для них необходимо передать значения:

# class Person:                   # определение класса Person
#     def say(self, message):     # метод
#         print(message)

# tom = Person()
# tom.say("Hello METANIT.COM")     # Hello METANIT.COM

# Здесь определен метод say(). Он принимает два параметра: self и message. И для второго параметра - message при вызове метода необходимо передать значение.

# Для обращения к атрибутам и методам объекта внутри класса в его методах также применяется слово self:

# self.атрибут    # обращение к атрибуту
# self.метод      # обращение к методу

# Например, следующий класс Person:

# class Person:

#     def __init__(self, name, age):
#         self.name = name     # имя человека
#         self.age = age       # возраст человека

#     def display_info(self):
#         print(f"Name: {self.name} Age: {self.age}")


# tom = Person("Tom", 22)
# tom.display_info()      # Name: Tom  Age: 22

# bob = Person("Bob", 43)
# bob.display_info()      # Name: Bob  Age: 43

# Здесь определяется метод display_info(), который выводит информацию на консоль. И для обращения в методе к атрибутам объекта применяется слово self: self.name и self.age


# ДЕСТРУКТОРЫ

# Кроме конструкторов классы в Python также могут определять специальные методы - деструкторы, которые вызываются при удалении объекта. Деструктор представляет собой метод __del__(self), в который, как и в конструктор, передается ссылка на текущий объект. В деструкторе определяются действия, которые надо выполнить при удалении объекта, например, освобождение или удаление каких-то ресурсов, которые использовал объект.

# Деструктор вызывается автоматически интерпретатором, нам не нужно его явным образом вызывать. Простейший пример:

# class Person:

#     def __init__(self, name):
#         self.name = name
#         print("Создан человек c именем", self.name)

#     def __del__(self):
#         print("Удален человек c именем", self.name)

# tom = Person("Tom")
# # Создан человек c именем Tom
# # Удален человек c именем Tom

# Здесь в деструкторе просто выведится уведомление об удалении объекта Person. Программа создает один объект Person и хранит ссылку на него в переменной tom. Создание объекта вызовет выполнение конструктора. При завершении программы автоматически будет выполняться деструктор объекта tom.

# Другой пример:

# class Person:

#     def __init__(self, name):
#         self.name = name
#         print("Создан человек c именем", self.name)

#     def __del__(self):
#         print("Удален человек c именем", self.name)


# def create_person():
#     tom = Person("Tom")

# create_person()
# print("Конец программы")
# # Создан человек c именем Tom
# # Удален человек c именем Tom
# # Конец программы

# Здесь объект Person создается и используется внутри функции create_person, поэтому жизнь создаваемого объекта Person ограничена областью этой функции. Соответственно, когда функция завершит свое выполнение, у объекта Person будет вызываться деструктор.

# УПРАЖНЕНИЯ

# 1.
# Определите класс Rectangle, который представляет прямоугольник. Через конструктор класс принимает ширину и длину и сохраняет их в атрибутах width и length соответственно. Также в этом классе определите метод area, который возвращает площадь прямоугольника, и метод perimeter, который возвращает периметра прямоугольника.
# После создания класса определите несколько объектов класса Rectangle и продемонстрируйте работу его методов.

# class Rectangle:
#     def __init__(self, width, length):
#         self.width = width
#         self.length = length
#     def area(self):
#         return self.width * self.length
#     def perimeter(self):
#         return (self.width + self.length) * 2

# rect1 = Rectangle(10, 15)
# print(rect1.area())         # 150
# print(rect1.perimeter())    # 50

# rect2 = Rectangle(20, 10)
# print(rect2.area())         # 200
# print(rect2.perimeter())    # 60


# 2.
# Создайте класс BankAccount, который представляет банковский счет. Определите в этом классе атрибуты account_number и balance, которые представляют номер счета и баланс. Через параметры конструктора передайте этим атрибутам начальные значения.

# Также в классе определите метод add, который принимает некоторую сумму и добавляет ее на баланс счета. И определите метод withdraw, который принимает некоторую сумму и снимает ее с баланса. При этом с баланса нельзя снять больше, чем имеется. Если на балансе недостаточно средств, то пользователю должно выводиться соответствующее сообщение.

# class BankAccount:
#     def __init__(self, number, sum):
#         self.account_number = number
#         self.balance = sum
#         print(f"Создан счет. Начальный баланс: {sum} единиц")

#     def add(self, sum):
#         self.balance = self.balance + sum
#         print(f'Зачислено: {sum}')

#     def withdraw(self, sum):
#         if self.balance >= sum:
#             self.balance = self.balance - sum
#             print(f'Снято: {sum}')
#         else:
#             print('No money')


# acc1 = BankAccount('12345678', 1000)
# acc1.add(200)
# acc1.withdraw(500)
# acc1.withdraw(300)
# acc1.withdraw(900)
# # Создан счет. Начальный баланс: 1000 единиц
# # Зачислено: 200
# # Снято: 500
# # Снято: 300
# # No money


# ИНКАПСУЛЯЦИЯ, АТРИБУТЫ И СВОЙСТВА

# По умолчанию атрибуты в классах являются общедоступными, а это значит, что из любого места программы мы можем получить атрибут объекта и изменить его. Например:

# class Person:
#     def __init__(self, name, age):
#         self.name = name           # устанавливаем имя
#         self.age = age             # устанавливаем возраст
        
#     def print_person(self):
#         print(f'Имя : {self.name} Возраст : {self.age}')
        
        
# tom = Person('Tom', 39)
# tom.name = "Человек-паук"       # изменяем атрибут name
# tom.age = -129                  # изменяем атрибут age
# tom.print_person()              # Имя: Человек-паук     Возраст: -129

# Эти изменения атрибутов name и age (ошибочно указанный возраст) - крайне нежелательны, поэтому встает вопрос о контроле за доступом к атрибутам объекта.

# С данной проблемой тесно связано понятие инкапсуляции. Инкапсуляция является фундаментальной концепцией объектно-ориентированного программирования, которая предполагает скрытие функционала и предотвращение прямого доступа извне к нему.
 
# Язык программирования Python позволяет определить приватные или закрытые атрибуты. Для этого имя атрибута должно начинаться с двойного подчеркивания - __name. Например, перепишем предыдущую программу, сделав оба атрибута - name и age приватными:

# class Person:
#     def __init__(self, name, age):
#         self.__name = name           # устанавливаем имя
#         self.__age = age             # устанавливаем возраст
        
#     def print_person(self):
#         print(f'Имя : {self.__name} Возраст : {self.__age}')
        
        
# tom = Person("Tom", 39)
# tom.__name = "Человек-паук"      # пытаемся изменить атрибут __name
# tom.__age = -129                 # пытаемся изменить атрибут __
# tom.print_person()               # Имя: Tom        Возраст: 39

# Как видим попытка изменить атрибуты не увенчалась успехом и первоначальные атрибуты остались в неприкосновенности т.о были исключены ошибки.

# Тем не менее приватность атрибутов тут довольно относительна. Например, мы можем использовать полное имя атрибута (например: tom._Person__name вместо tom.__name) и тогда присвоить новые значения получится:

# class Person:
#     def __init__(self, name, age):
#         self.__name = name       # устанавливаем имя
#         self.__age = age         # устанавливаем возраст

#     def print_person(self):
#         print(f'Имя : {self.__name} Возраст : {self.__age}')


# tom = Person("Tom", 39)
# tom._Person__name = "Человек-паук"   # изменяем атрибут __name
# tom.print_person()                   # Имя: Человек-паук   Возраст: 39


# МЕТОДЫ ДОСТУПА. ГЕТТЕРЫ и СЕТТЕРЫ

# получающими методами (ГЕТТЕРАМИ) называют методы, которые позволяют нам получать значения приватных атрибутов извне класса.
# устанавливающие методы (СЕТТЕРЫ) это методы, которые позволяют нам устанавливать значения частных атрибутов извне класса.

# Может возникнуть вопрос, как обращаться к подобным приватным атрибутам. Для этого обычно применяются специальные методы доступа. Геттер позволяет получить значение атрибута, а сеттер установить его.

# class Person:
#     def __init__(self, name, age):
#         self.__name = name       # устанавливаем имя
#         self.__age = age         # устанавливаем возраст

#     # сеттер для установки возраста
#     def set_age(self, age):
#         if 0 < age < 110:
#             self.__age = age
#         else:
#             print("Недопустимый возраст")

#     # геттер для получения значения возраста
#     def get_age(self):
#         return self.__age

#     # геттер для получения имени
#     def get_name(self):
#         return self.__name

#     def print_person(self):
#         print(f'Имя : {self.__name} Возраст : {self.__age}')


# tom = Person("Tom", 39)
# tom.print_person() # Имя: Tom  Возраст: 39
# tom.set_age(-3486) # Недопустимый возраст
# tom.set_age(25)
# tom.print_person() # Имя: Tom  Возраст: 25

# Так опосредование доступа к атрибутам через методы позволяет задать дополнительную логику в зависимости от переданного возраста мы можем решить, надо ли переустанавливать возраст, так как переданное значение может быть некорректным.

# Также необязательно создавать для каждого приватного атрибута подобную пару методов. Так, в примере выше имя человека мы можем установить только из конструктора. А для получения определен метод get_name.


# АННОТАЦИИ СВОЙСТВ

# Выше мы рассмотрели, как создавать методы доступа. Но Python имеет также еще один - более элегантный способ - свойства. Этот способ предполагает использование аннотаций, которые предваряются символом @.

# Для создания свойства-геттера над свойством ставится аннотация @property.

# Для создания свойства-сеттера над свойством устанавливается аннотация имя_свойства_геттера.setter.

# Перепишем класс Person с использованием аннотаций:

# class Person:
#     def __init__(self, name, age):
#         self.__name = name   # устанавливаем имя
#         self.__age = age     # устанавливаем возраст

#     # свойство-геттер
#     @property
#     def age(self):
#         return self.__age
#     # свойство-сеттер
#     @age.setter
#     def age(self, age):
#         if 0 < age < 110:
#             self.__age = age
#         else:
#             print("Недопустимый возраст")

#     @property
#     def name(self):
#         return self.__name

#     def print_person(self):
#         print(f'Имя : {self.__name} Возраст : {self.__age}')


# tom = Person("Tom", 39)
# tom.print_person()  # Имя: Tom  Возраст: 39
# tom.age = -3486     # Недопустимый возраст  (Обращение к сеттеру)
# print(tom.age)      # 39 (Обращение к геттеру)
# tom.age = 25        # (Обращение к сеттеру)
# tom.print_person()  # Имя: Tom  Возраст: 25

# Во-первых, стоит обратить внимание, что свойство-сеттер определяется после свойства-геттера.

# Во-вторых, и сеттер, и геттер называются одинаково - age. И поскольку геттер называется age, то над сеттером устанавливается аннотация @age.setter.

# После этого, что к геттеру, что к сеттеру, мы обращаемся через выражение tom.age.

# При этом можно определить только геттер, как в случае с свойством name - его нельзя изменить, а можно лишь получить значение.


# НАСЛЕДОВАНИЕ

# Наследование позволяет создавать новый класс на основе уже существующего класса. Наряду с инкапсуляцией наследование является одним из краеугольных камней объектно-ориентированного программирования.

# Ключевыми понятиями наследования являются подкласс и суперкласс. Подкласс наследует от суперкласса все публичные атрибуты и методы. Суперкласс еще называется базовым (base class) или родительским (parent class), а подкласс - производным (derived class) или дочерним (child class).

# Синтаксис для наследования классов выглядит следующим образом:

# class подкласс (суперкласс):
#     методы_подкласса

# Например, у нас есть класс Person, который представляет человека:
