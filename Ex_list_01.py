# Упражнение 110. Порядок сортировки

# Напишите программу, которая будет запрашивать у пользователя целочисленные значения и сохранять их в виде списка. Индикатором окончания ввода значений должен служить ноль. Затем программа должна вывести на экран все введенные пользователем числа (кроме нуля) в порядке возрастания – по одному значению в строке. Используйте для сортировки либо метод sort, либо функцию sorted.

# data = []

# num = int(input("Введите целое число (0 для окончания ввода): "))
# while num != 0:
#     data.append(num)
#     num = int(input("Введите целое число (0 для окончания ввода): "))

# print(data)
# data.sort()
# print(data)
# print("Введенные числа в порядке возрастания: ")
# for num in data:
#     print(num, end=' ')


# Упражнение 111. Обратный порядок

# Напишите программу, которая, как и в предыдущем случае, будет запрашивать у пользователя целые числа и сохранять их в виде списка. Индикатором окончания ввода значений также должен служить ноль. На этот раз необходимо вывести на экран введенные значения в порядке убывания.

# data = []
# num = int(input("Введите целое число (0 для окончания ввода): "))

# while num != 0:
#     data.append(num)
#     num = int(input("Введите целое число (0 для окончания ввода): "))

# data.sort()
# print(data)
# data.reverse()
# print(data)

# for num in data:
#     print(num, end=' ')


# Упражнение 112. Удаляем выбросы (data processing)

# При анализе собранных по результатам научных экспериментов данных зачастую возникает необходимость избавиться от экстремальных значений, прежде чем продолжать двигаться дальше. Напишите функцию, создающую копию списка с исключенными из него n наибольшими и наименьшими значениями и возвращающую ее в качестве результата. Порядок следования элементов в измененном списке не обязательно должен в точности совпадать с источником.
# В основной программе должна быть продемонстрирована работа вашей функции. Для начала попросите пользователя ввести целые числа, затем соберите их в список и вызовите написанную вами ранее функцию. Выведите на экран измененную версию списка вместе с оригинальной. Если пользователь введет менее четырех чисел, должно быть отображено соответствующее сообщение об ошибке.


# data = []

# num = int(input("Введите целое число (0 для окончания ввода): "))
# while num != 0:
#     data.append(num)
#     num = int(input("Введите целое число (0 для окончания ввода): "))

# while len(data) <= 4:
#     num = int(input("Введите целое число (0 для окончания ввода): "))
#     data.append(num)
# print(data)

# my_set = set(data)
# data = list(my_set)
# data.sort()
# print(data)

# data.pop()
# data.pop(0)
# print(data)


# Упражнение 113. Избавляемся от дубликатов

# В данном упражнении вам предстоит разработать программу, в которой у пользователя будет запрошен список слов, пока он не оставит строку ввода пустой. После этого на экране должны быть показаны слова, введенные пользователем, но без повторов, – каждое по одному разу. При этом слова должны быть отображены в том же порядке, в каком их вводили с клавиатуры. Например, если пользователь на запрос программы введет следующий список слов:
# first
# second
# first
# third
# second
# программа должна вывести:
# first
# second
# third

# data = []

# word = input('Введите слово (всего их потребуется пять. B конце нажмите Enter): ')
# while word != "":
#     data.append(word)
#     word = input('Введите слово (всего их потребуется пять. B конце нажмите Enter): ')

# data = list(dict.fromkeys(data))
# print(data)
# for item in data:
#     print(item)
# # все работает

# Упражнение 114. Отрицательные, положительные и нули.

# Напишите программу, запрашивающую у пользователя целые числа, пока он не оставит строку ввода пустой. После окончания ввода на экран должны быть выведены сначала все отрицательные числа, которые были введены, затем нулевые и только после этого положительные. Внутри каждой группы числа должны отображаться в той последовательности, в которой были введены пользователем. Например, если он ввел следующие числа: 3, -4, 1, 0, -1, 0 и -2, вывод должен оказаться таким: -4, -1, -2, 0, 0, 3 и 1.Каждое значение должно отображаться на новой строке.

# data1 = []
# data2 = []
# data3 = []
# # ввел 9, 7, -5, -6, 0, 3, -1, 0
# line = input("Введите целое число (Enter для окончания ввода): ")

# while line != "":
#     num = int(line)
#     if num < 0:
#         data1.append(num)
#     elif num > 0:
#         data3.append(num)
#     else:
#         data2.append(num)

#     num = line = input("Введите целое число (Enter для окончания ввода): ")

# data = data1 + data2 + data3
# for item in data:
#     print(item, end=' ') # -5 -6 -1 0 0 9 7 3


# Упражнение 115. Список собственных делителей

# Собственным делителем числа называется всякий его делитель, отличный от самого числа. Напишите функцию, которая будет возвращать список всех собственных делителей заданного числа. Само это число должно передаваться в функцию в виде единственного аргумента. Результатом функции будет перечень собственных делителей числа, собранных в список. Основная программа должна демонстрировать работу функции, запрашивая у пользователя число и выводя на экран список его собственных делителей. Программа должна запускаться только в том случае, если она не импортирована в виде модуля в другой файл.

# def main():
#     num = int(input("Введите целое число: "))
#     properDivisors(num)

# def properDivisors(num):
#     divisors = []
#     n = list(range(1, num))
#     for i in n:
#         if num % i == 0:
#             divisors.append(i)
#     print(divisors)
# main()

# Ваш код можно улучшить как с точки зрения эффективности, так и с точки зрения стиля. Приведённый ниже код имеет улучшения, включая использование списка списков и генераторов, а также более ясные имена функций. Кроме того, проверку на целочисленность можно сделать при помощи обработки исключений для обеспечения корректного ввода:

# def main():
#     try:
#         num = int(input("Введите целое число: "))
#         divisors = find_proper_divisors(num)
#         print("Делители:", divisors)
#     except ValueError:
#         print("Пожалуйста, введите корректное целое число.")

# def find_proper_divisors(num):
#     return [i for i in range(1, num) if num % i == 0]

# if __name__ == "__main__":
#     main()

# Изменения и улучшения:

# 1. Именование функций: Я изменил имя функции properDivisors на find_proper_divisors, чтобы лучше отражать её назначение.

# 2. Использование генераторов списков: Это упрощает код и может повысить производительность, особенно при больших числах.

# 3. Обработка ошибок: Добавление обработки исключений позволяет избежать сбоев, если пользователь введёт неправильный тип данных.

# 4. Основная точка входа: Проверка if __name__ == "__main__": позволяет использовать функцию main и в качестве исполняемого скрипта, и в качестве импортируемого модуля.


# Упражнение 116. Совершенные числа

# Целое число n называется совершенным, если сумма всех его собственных делителей равна самому числу n. Например, 28 – это совершенное число, поскольку его собственными делителями являются 1, 2, 4, 7 и 14, а 1 + 2+ 4 + 7 + 14 = 28.
# Напишите функцию для определения того, является ли заданное число совершенным. Функция будет принимать на вход единственный параметр и возвращать True, если он представляет собой совершенное число, и False – если нет. Разработайте небольшую программу, которая будет использовать функцию для идентификации и вывода на экран всех совершенных чисел в диапазоне от 1 до 10 000. При решении этой задачи импортируйте функцию, написанную в упражнении 115.

# Вот программа на Python, которая использует функцию для идентификации и вывода всех совершенных чисел в диапазоне от 1 до 1000:


# def is_perfect_number(num):
#     """Проверяет, является ли число совершенным."""
#     if num < 1:
#         return False
#     divisors_sum = sum(i for i in range(1, num) if num % i == 0)
#     return divisors_sum == num

# def find_perfect_numbers(limit):
#     """Ищет все совершенные числа в заданном диапазоне."""
#     perfect_numbers = []
#     for i in range(1, limit + 1):
#         if is_perfect_number(i):
#             perfect_numbers.append(i)
#     return perfect_numbers

# def main():
#     limit = 1000
#     perfect_numbers = find_perfect_numbers(limit)
#     print(f"Совершенные числа в диапазоне от 1 до {limit}: {perfect_numbers}")

# if __name__ == "__main__":
#     main()


# Как работает код:
# 1. Функция `is_perfect_number(num) - Принимает целое число и вычисляет сумму его делителей (исключая само число).
# - Возвращает `True`, если сумма делителей равна числу, иначе — `False`.

# 2. Функция `find_perfect_numbers(limit)`:
# - Перебирает числа от 1 до заданного лимита.
# - Использует `is_perfect_number()` для проверки, является ли каждое число совершенным.
# - Возвращает список всех совершенных чисел.

# 3. Функция `main()`:
# - Определяет лимит, вызывает функцию для поиска совершенных чисел и выводит их на экран.

# Результат:
# Когда вы запустите эту программу, она выведет все совершенные числа в диапазоне от 1 до 1000. Совершенные числа в этом диапазоне: **6, 28, 496**.
# -------------------------------------------------------------------------------


# Упражнение 118. Словесные палиндромы
# Напишите программу, которая будет запрашивать строку у пользователя и оповещать его о том, является ли она словесным палиндромом. Не забывайте игнорировать знаки препинания при выявлении результата.

# Для проверки работы программы используйте предложение: "Herb the sage eats sage, the herb" или "Information school graduate seeks graduate school information"

# my_string = "Information school graduate seeks graduate school information"
# my_string = my_string.lower()
# word_list = my_string.split()

# new_word_list = word_list[::-1]

# if new_word_list == word_list:
#     print("Строка является словесным полиндромом")
# else:
#     print("Строка словесным палиндромом не явяется")

# # ['information', 'school', 'graduate', 'seeks', 'graduate', 'school', 'information']
# print(word_list)
# # ['information', 'school', 'graduate', 'seeks', 'graduate', 'school', 'information']
# print(new_word_list)
# Строка является словесным полиндромом


# Упражнение 120. Форматирование списка
# Напишите функцию, которая будет принимать на вход список из строк и возвращать собранную строку из его элементов в описанной выше манере. Хотя в представленном примере количество элементов списка ограничивается четырьмя, ваша функция должна уметь обрабатывать списки любой длины.
# В основной программе запросите у пользователя несколько элементов списка, отформатируйте их должным образом при помощи функции и выведите на экран.

# def formatList(items):
#     result = ""
#     for i in range(0, len(items) - 2):
#         result = result + str(items[i]) + ', '
#     result = result + str(items[len(items) - 2]) + ' and '
#     result = result + str(items[len(items) - 1])
#     return result


# items1 = ['apple', 'greep', 'banana', 'lemon']
# print(formatList(items1))              # apple, greep, banana and lemon
# items2 = ['10', '9', '6', '2', '7', 3]
# print(formatList(items2))              # 10, 9, 6, 2, 7 and 3


# Упражнение 121. Случайные лотерейные номера
# Для выигрыша главного приза необходимо, чтобы шесть номеров на лотерейном билете совпали с шестью числами, выпавшими случайным образом в диапазоне от 1 до 49 во время очередного тиража. Напишите программу, которая будет случайным образом подбирать шесть номеров для вашего билета. Убедитесь в том, что среди этих чисел не будет дубликатов.
# Выведите номера билетов на экран по возрастанию.

# import random


# def generates_random_num():
#     unique_randoms = random.sample(range(1, 50), 6)
#     unique_randoms.sort()
#     for nums in unique_randoms:
#         print(nums, end=' ')


# generates_random_num()


# Упражнение 128. Подсчитать элементы в списке

# В данном упражнении вы создадите новую функцию countRange, которая будет подсчитывать количество элементов в списке, значения которых больше или равны заданному минимальному порогу и меньше максимального. Функция должна принимать три параметра: список, минимальную границу и максимальную границу. Возвращать она будет целочисленное значение, большее или равное нулю. В основной программе реализуйте демонстрацию вашей функции для нескольких списков с разными минимальными и максимальными границами.
# Удостоверьтесь, что программа будет корректно работать со списками, содержащими как целочисленные значения, так и числа с плавающей запятой.

# def count_range(my_list, min_num, max_nam):
#     my_nums = []
#     for num in my_list:
#         if num >= min_num and num < max_nam:
#             my_nums.append(num)
#     return (len(my_nums))


# print(count_range([5, 8, 10, 16, 11, 18, 4], 8, 16))


# Упражнение 127. Список уже отсортирован?

# Напишите функцию, показывающую, отсортирован ли переданный ей в качестве параметра список (по возрастанию или убыванию). Функция должна возвращать True, если список отсортирован, и False в противном случае. В основной программе запросите у пользователя последовательность чисел для списка, после чего выведите сообщение о том, является ли этот список отсортированным изначально.

# Примечание. Убедитесь в том, что вы правильно обрабатываете пустые списки, а также списки, состоящие из единственного элемента.


# def get_bool_foo(my_data):
#     return my_data == sorted(my_data) or my_data == sorted(my_data, reverse=True)

# def main():
#     data = []
#     line = input("Vedite celoe chislo (Enter dla okoncgania): ")
#     while line != '':
#         n = int(line)
#         data.append(n)
#         line = input("Vedite celoe chislo (Enter dla okoncgania): ")
#     print(data)
#     if get_bool_foo(data):
#         print("Список отсортирован")
#     else:
#         print("Спмсок не отсортирован")

# if __name__ == "__main__":
#     main()

# ----------------------------------------------------------------------------------

# def is_sorted(lst):
#     """Проверяет, отсортирован ли список по возрастанию или убыванию."""
#     return lst == sorted(lst) or lst == sorted(lst, reverse=True)

# def main():
#     # Запрашиваем у пользователя последовательность чисел
#     user_input = input("Введите последовательность чисел, разделенных пробелом: ")
#     # Преобразуем введенные значения в список чисел
#     number_list = list(map(int, user_input.split()))
#     print(number_list)

#     # Проверяем, отсортирован ли список
#     if is_sorted(number_list):
#         print("Список отсортирован.")
#     else:
#         print("Список не отсортирован.")

# # Запускаем основную программу
# if __name__ == "__main__":
#     main()

# Как это работает:
# Функция is_sorted(lst):

# Использует встроенные функции sorted() для проверки, совпадает ли оригинальный список с отсортированным по возрастанию или убыванию.
# Возвращает True, если список отсортирован, и False в противном случае.
# Функция main():

# Запрашивает у пользователя ввод чисел, разделенных пробелами.
# Преобразует строку введенных чисел в список целых чисел.
# Вызывает функцию is_sorted() и выводит соответствующее сообщение.
# --------------------------------------------------------------------------------------


# Упражнение 134. Все подсписки заданного списка

# Используя определение подсписка из упражнения 133, напишите функцию, возвращающую список, содержащий все возможные подсписки заданного. Например, в число подсписков списка [1, 2, 3] входят следующие: [], [1], [2], [3], [1, 2], [2, 3] и [1, 2, 3]. Заметьте, что ваша функция должна вернуть как минимум один пустой список, гарантированно являющийся подсписком для любого списка. Напишите основную программу, демонстрирующую работу функции применительно к нескольким исходным спискам.

# def allSublists(data):
#     sublists = [[]]
#     for k in range(1, len(data)+1):
#         for i in range(0, len(data) - k + 1):
#             sublists.append(data[i:i + k])
#     return sublists


# def main():
#     print("Подсписки []: ")
#     print(allSublists([]))  # [[]]
#     print()
#     print("Подсписки [1]: ")
#     print(allSublists([1]))  # [[], [1]]
#     print()
#     print("Подсписки [1, 2]: ")
#     print(allSublists([1, 2]))  # [[], [1], [2], [1, 2]]
#     print()
#     print("Подсписки [1, 2, 3]: ")
#     # [[], [1], [2], [3], [1, 2], [2, 3], [1, 2, 3]]
#     print(allSublists([1, 2, 3]))
#     print()
#     print("Подсписки [1, 2, 3, 4]: ")
#     # [[], [1], [2], [3], [4], [1, 2], [2, 3], [3, 4], [1, 2, 3], [2, 3, 4], [1, 2, 3, 4]]
#     print(allSublists([1, 2, 3, 4]))


# if __name__ == '__main__':
#     main()


# Упражнение 135. Решето Эратосфена в границах от 0 до 50.

# Выписываем все целые числа от 0 до заданной границы
# Вычеркиваем 0 и 1 как непростые числа
# Устанавливаем значение переменной p, равное 2
# Пока p меньше числа заданной границы, делать: Вычеркиваем все числа, кратные p, но не его самого.
# Устанавливаем значение p, равное следующему невычеркнутому числу.
# Выводим все числа, оставшиеся незачеркнутыми.

# 1-й вариант:

# limit = 20
# nums = []

# for i in range(0, limit + 1):
#     nums.append(i)

# nums[1] = 0
# p = 2

# while p < limit:
#     for i in range(p * 2, limit + 1, p):
#         nums[i] = 0
#     p = p + 1
#     while p < limit and nums[p] == 0:
#         p = p + 1
# my_nums = []
# for i in nums:
#     if i != 0:
#         my_nums.append(i)
# print(my_nums)  # [2, 3, 5, 7, 11, 13, 17, 19]


# 2-й вариант:

# Решето Эратосфена — это эффективный алгоритм для нахождения всех простых чисел до заданного числа \( n \). Давайте реализуем его в Python для нахождения простых чисел в диапазоне от 0 до 20.
# Вот пример кода:

# def sieve_of_eratosthenes(n):
#     primes = [True] * (n + 1)  # Создаем список булевых (True) значений
#     p = 2  # Первый простой номер

#     while (p * p <= n):
#         # Если primes[p] не изменилось, значит p - простое
#         if primes[p]:
#             # Обновляем все кратные p, начиная с p*2
#             for i in range(p * p, n + 1, p):
#                 primes[i] = False
#         p += 1

#     # Собираем все простые числа
#     prime_numbers = [p for p in range(2, n + 1) if primes[p]]
#     return prime_numbers

# # Вызов функции для нахождения простых чисел до 20
# primes_up_to_50 = sieve_of_eratosthenes(20)
# print(primes_up_to_50)

# При запуске этого кода, результат будет следующим:

# [2, 3, 5, 7, 11, 13, 17, 19]


# Как это работает:

# 1. **Инициализация**: Создаём список `primes` длиной `n + 1`, где все значения изначально установлены в `True`. Индексы списка будут представлять числа от 0 до \( n \).
# 2. **Основной цикл**: Начинаем с первого простого числа \( 2 \). Если число простое (значение `True`), помечаем все его кратные как непростые (значение `False`).
# 3. **Сбор результатов**: После завершения итераций собираем все индексы, которые остались помеченными как `True`, что и будут простыми числами.


# УПРАЖНЕНИЕ 1. Оценки за ежемесячные тесты (Лернер Р. - Python. Pandas на практике - 2025)

# Создайте объект Series, состоящий из десяти случайных целочисленных значений в диапазоне от 70 до 100, которые будут представлять оценки студента за ежемесячные тесты. Задайте в качестве индекса названия месяцев с сентября по июнь. Если эти месяцы не соответствуют началу и окончанию учебного года в вашем регионе, вы можете адаптировать их.
# Напишите код, который будет отвечать на следующие вопросы:

# 1. какова средняя оценка студента за тесты за весь год?
# 2. какова средняя оценка студента за тесты за первое полугодие (т. е. за первые пять месяцев учебного года)?
# 3. какова средняя оценка студента за тесты за второе полугодие (т. е. за последние пять месяцев учебного года)?
# 4. повысилась ли успеваемость студента во втором полугодии в сравнении с первым? Если да, то насколько?

# import random

# nums_random = [random.randint(70, 101) for _ in range(10)]
# months = 'Sep Oct Nov Dec Jan Feb Mar Apr May Jun'.split()
# my_dict = dict(zip(months, nums_random))
# print(my_dict)  # {'Sep': 97, 'Oct': 71, 'Nov': 81, 'Dec': 85, 'Jan': 70, 'Feb': 74, 'Mar': 97, 'Apr': 78, 'May': 95, 'Jun': 97}

# yearly_average = sum(nums_random) / len(nums_random)
# print(yearly_average)  # 84.5

# first_half_average = sum(nums_random[0:5]) / (len(nums_random) / 2)
# print(first_half_average)  # 80.8

# second_half_average = sum(nums_random[5:10]) / (len(nums_random) / 2)
# print(second_half_average)  # 88.2

